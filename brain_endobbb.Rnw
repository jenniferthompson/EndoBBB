%% -- Specially formatted Latex comment tells RStudio to compile PDF with knitr
% !Rnw weave = knitr

\documentclass{article}

%\usepackage[margin=.5in, landscape]{geometry} %resets margins
\usepackage[margin=.45in]{geometry} %resets margins
\usepackage{hyperref}
\usepackage{lscape}
\usepackage{pdfpages}

\title{BRAIN-ICU: Endothelial and BBB/Brain Injury vs. Delirium and Long-Term Outcomes}
\date{\today}
\author{Jennifer Thompson, MPH; Supervisor: Rameela Chandrasekhar, PhD}
\begin{document}
\maketitle
\tableofcontents
\listoftables
\listoffigures
\clearpage

<<setup, include=FALSE, results='hide', cache=FALSE>>=
opts_chunk$set(echo=FALSE, warning = FALSE, message = FALSE, cache = FALSE, error = FALSE, results='hide')
options(replace.assign = TRUE, width = 90)

library(ClusterBootMultinom)
library(mice)
library(MASS)
library(pscl)
library(rms)
library(ggplot2)
library(dplyr)
library(tidyr)
library(devtools)

@

The following analyses examine the relationships between endothelial/blood-brain barrier (BBB)
injury at BRAIN study enrollment and delirium duration, long-term cognitive outcomes (RBANS and
Trails B), and long-term disability outcomes (Katz ADL and Functional Activities Questionnaire)
among BRAIN-ICU survivors with both endothelial marker data and at least partial long-term outcomes.
They also investigate whether these associations are modified by either age or systemic
inflammation, as measured by IL-6 at study enrollment.

\textbf{Important note:} Because these endothelial/BBB markers were measured only on ICU survivors
with long-term followup outcomes available, the results are \textbf{only} applicable to that
population.

<<datamgmt>>=
## Set cutoff for p-values for keeping nonlinear, interaction terms in model
pcutoff <- 0.2

## Set number of imputations
nimp <- 50

## Set number of bootstraps for zero-inflated models
n.bootsets <- 500

## Set method to use in pool.compare() (Wald or likelihood)
use.method <- 'likelihood'

## Prefixes of biomarker variables for use in lapply()
endo.names <- c('bdnf', 'esel', 'pai1', 's100b', 'uchl')

## Load all BRAIN data
if(Sys.info()['sysname'] == 'Darwin'){
  if(length(grep('Volumes', getwd())) > 0){
    load('/Volumes/thomps23/ICUDelirium/BRAINICU/braindata.Rdata')
    source('/Volumes/thomps23/R/multiplot.r')
    source('/Volumes/thomps23/R/rmsHelpers/model_results.R')
    source('/Volumes/thomps23/R/rmsHelpers/combine_cohorts.R')
    source('/Volumes/thomps23/R/rmsHelpers/latex_rms_results.R')
  } else{
    load('braindata.Rdata')
    source('multiplot.r')
    source('model_results.R')
    source('combine_cohorts.R')
    source('latex_rms_results.R')
  }
} else{
  load('/home/thomps23/ICUDelirium/BRAINICU/braindata.Rdata')
  source('/home/thomps23/R/multiplot.r')
  source('/home/thomps23/R/rmsHelpers/model_results.R')
  source('/home/thomps23/R/rmsHelpers/combine_cohorts.R')
  source('/home/thomps23/R/rmsHelpers/latex_rms_results.R')
}

## Read in biomarker data from .csv files from Brennan
marker.data <- bind_rows(lapply(endo.names, FUN = function(x){
  tmp <- read.csv(paste0(x, '_2nov2015.csv'))[,1:4]
  tmp$marker <- x
  tmp[!is.na(tmp$id),]
})) %>%
  ## Delete if coefficient of variance > 30; indicates nonreproducibility of marker results
  filter(cv < 30 | mean.pgml == -9999) %>%
  ## Get one variable per marker mean
  select(id, marker, mean.pgml) %>%
  spread(key = marker, value = mean.pgml) %>%
  ## Delete PAI-1 values for 5 patients with unreliable values;
  ##  see email discussion with Brennan, 11/17/2015
  mutate(pai1 = ifelse(id %in% c(11262, 11265, 11266, 11173, 11480), NA, pai1))

names(marker.data)[2:ncol(marker.data)] <- paste0(names(marker.data)[2:ncol(marker.data)], '.day1')

## Function to impute randomly sampled value in a "low" range ##
## LLD for S100B = 2.7
## LLD for UCHL = 60
impute.lld <- function(x, ## object to be imputed
                       lld.val, ## value (numeric) indicating marker is below limit of detection
                       na.vals, ## value(s) (numberic) indicating marker is truly missing,
                       min.val, max.val){ ## limits of range (usually 0-lower limit)
  if(!is.na(x) & x %nin% c(lld.val, na.vals)){
    return(x)
  } else if(!is.na(x) & x == lld.val){
    set.seed(56)
    return(runif(n = 1, min = min.val, max = max.val))
  } else{
    return(NA)
  }
}

marker.data$s100b.day1 <- unlist(lapply(marker.data$s100b.day1,
                                        FUN = impute.lld,
                                        lld.val = -9999,
                                        na.vals = -1,
                                        min.val = 0, max.val = 2.7))
marker.data$uchl.day1 <- unlist(lapply(marker.data$uchl.day1,
                                       FUN = impute.lld,
                                       lld.val = -9999,
                                       na.vals = -1,
                                       min.val = 0, max.val = 60))

## -- Merge biomarker data onto BRAIN data ---------------------------------------------------------
oneobs.vars <- c('id', 'age.enroll', 'sex.pp', 'race.pp', 'edu', 'charlson.score', 'iqcode.score.e',
                 'stroke.risk', 'adl.e', 'faq.e', 'frailty', 'admit.dx', 'icu.type', 'num.apache',
                 'apache.aps', 'sofa', 'mean.modsofa.icu',
                 'mean.benz.icu', 'mean.op.new.icu', 'mean.prop.icu', 'mean.dex.icu',
                 'mean.hal.icu',
                 'ever.vent.s', 'vent.los.tot.eo',
                 'ever.del.s.imp', 'del.s.imp', 'del.s.imp.eo',
                 'ever.coma.s.imp', 'coma.s.imp', 'coma.s.imp.eo',
                 'ever.sevseptic.s', 'icudays.sevseptic.s', 'icudays.sevseptic.eo')

## Put followup test scores in wide format
fu.data <- brain.fu %>%
  filter(fu.period %in% c('3 Month', '12 Month')) %>%
  select(id, fu.period, rbans.global.score, trail.b.tscore, adl.totscore, faq.totscore) %>%
  mutate(fu.period = gsub(' Month', '', fu.period),
         faq.rdscore = round(faq.totscore)) %>%
  gather(key = test, value = testscore, rbans.global.score:faq.rdscore) %>%
  mutate(test.time = paste(test, fu.period, sep = '.')) %>%
  filter(!is.na(testscore)) %>%
  select(-test, -fu.period) %>%
  spread(key = test.time, value = testscore)

## Get day 1 values from daily data
day1.data <- brain.daily %>%
  filter(study.day == 1) %>%
  select(id, il6.imp, sofa.cv, sevsepsis.l24)
names(day1.data) <- c('id', 'il6.day1', 'cvsofa.day1', 'sevsepsis.day1')

endo.data <- brain.oneobs[brain.oneobs$id %in% marker.data$id, oneobs.vars] %>%
  left_join(day1.data, by = 'id') %>%
  left_join(marker.data) %>%
  left_join(fu.data, by = 'id') %>%
  mutate(## Create variable for "disabled at baseline" (either ADL or FAQ > 0)
         disabled.e = ifelse(is.na(adl.e) & is.na(faq.e), NA,
                             (!is.na(adl.e) & adl.e > 0) | (!is.na(faq.e) & faq.e > 0)),
         ## Divide age / 10 to address scaling issue
         age.div10 = age.enroll / 10,
         edu.div10 = edu / 10,
         ## Create log10-transformed versions of endothelial markers
         il6.log10 = log10(il6.day1),
         bdnf.log10 = log10(bdnf.day1),
         esel.log10 = log10(esel.day1),
         pai1.log10 = log10(pai1.day1),
         s100b.log10 = log10(s100b.day1),
         uchl.log10 = log10(uchl.day1),
         ## Create indicators for whether patient is in each cohort at each time point
         cog.cohort.3 = !is.na(rbans.global.score.3) | !is.na(trail.b.tscore.3),
         cog.cohort.12 = !is.na(rbans.global.score.12) | !is.na(trail.b.tscore.12),
         func.cohort.3 = !is.na(adl.totscore.3) | !is.na(faq.totscore.3),
         func.cohort.12 = !is.na(adl.totscore.12) | !is.na(faq.totscore.12),
         cog.cohort.either = cog.cohort.3 | cog.cohort.12,
         func.cohort.either = func.cohort.3 | func.cohort.12) %>%
  ## Remove patients who had no RBANS, Trails B, ADL, or FAQ - must have had other partial outcomes
  filter(cog.cohort.either | func.cohort.either)

label(endo.data$mean.benz.icu) <- 'Mean 24h dose of benzos in the ICU (MDZ equiv.)'
label(endo.data$mean.op.new.icu) <- 'Mean 24h dose of opioids in the ICU (fentanyl equiv.)'
label(endo.data$mean.prop.icu) <- 'Mean 24h dose of propofol in the ICU'
label(endo.data$mean.dex.icu) <- 'Mean 24h dose of dex in the ICU'
label(endo.data$mean.hal.icu) <- 'Mean 24h dose of haldol in the ICU'
label(endo.data$cvsofa.day1) <- 'Cardiovasulcar SOFA score, study day 1'
label(endo.data$sevsepsis.day1) <- 'Severely septic, study day 1'
label(endo.data$disabled.e) <- 'Disabled at enrollment (ADL or FAQ > 0)'
label(endo.data$il6.day1) <- 'IL-6, study day 1'
label(endo.data$bdnf.day1) <- 'BDNF, study day 1'
label(endo.data$esel.day1) <- 'E-selectin, study day 1'
label(endo.data$pai1.day1) <- 'PAI-1, study day 1'
label(endo.data$s100b.day1) <- 'S100B, study day 1'
label(endo.data$uchl.day1) <- 'UCHL, study day 1'
label(endo.data$il6.log10) <- 'Log10(IL-6), study day 1'
label(endo.data$bdnf.log10) <- 'Log10(BDNF), study day 1'
label(endo.data$esel.log10) <- 'Log10(E-selectin), study day 1'
label(endo.data$pai1.log10) <- 'Log10(PAI-1), study day 1'
label(endo.data$s100b.log10) <- 'Log10(S100B), study day 1'
label(endo.data$uchl.log10) <- 'Log10(UCHL), study day 1'
label(endo.data$rbans.global.score.3) <- 'RBANS global score, 3m'
label(endo.data$rbans.global.score.12) <- 'RBANS global score, 12m'
label(endo.data$trail.b.tscore.3) <- 'Trails B T-score, 3m'
label(endo.data$trail.b.tscore.12) <- 'Trails B T-score, 12m'
label(endo.data$adl.totscore.3) <- 'ADL score, 3m'
label(endo.data$adl.totscore.12) <- 'ADL score, 12m'
label(endo.data$faq.totscore.3) <- 'FAQ score, 3m'
label(endo.data$faq.totscore.12) <- 'FAQ score, 12m'

## Create data set for descriptive tables
endo.data.desc <- bind_rows(endo.data,
                            endo.data[endo.data$cog.cohort.either,],
                            endo.data[endo.data$func.cohort.either,]) %>%
  mutate(cohort = factor(c(rep(1, nrow(endo.data)),
                           rep(2, sum(endo.data$cog.cohort.either)),
                           rep(3, sum(endo.data$func.cohort.either))),
                         levels = 1:3,
                         labels = c('Entire Cohort',
                                    'Cognitive Outcomes',
                                    'Functional Outcomes')),
         ## Revamp race and admission diagnosis variables to shorten categories
         race.pp = factor(as.character(race.pp)),
         admit.dx = factor(ifelse(admit.dx == 'Metabolic acidosis, hypovolemia, or electrolyte disturbance',
                                  'Metabolic acidosis/hypovolemia/electrolytes',
                                  as.character(admit.dx))))

label(endo.data.desc$age.enroll) <- 'Age at enrollment'
label(endo.data.desc$sex.pp) <- 'Sex'
label(endo.data.desc$race.pp) <- 'Race'
label(endo.data.desc$edu) <- 'Years of education'
label(endo.data.desc$charlson.score) <- 'Charlson score'
label(endo.data.desc$iqcode.score.e) <- 'IQCODE score (missing -> 3)'
label(endo.data.desc$stroke.risk) <- 'Framingham stroke risk profile'
label(endo.data.desc$adl.e) <- 'Katz ADL at enrollment'
label(endo.data.desc$faq.e) <- 'FAQ at enrollment'
label(endo.data.desc$disabled.e) <- 'Disabled at enrollment (ADL or FAQ > 0)'
label(endo.data.desc$frailty) <- 'CSHA Frailty at enrollment'
label(endo.data.desc$icu.type) <- 'ICU type'
label(endo.data.desc$admit.dx) <- 'Primary admission diagnosis'
label(endo.data.desc$num.apache) <- 'APACHE II at ICU admission'
label(endo.data.desc$sofa) <- 'SOFA at ICU admission'
label(endo.data.desc$mean.benz.icu) <- 'Mean 24h benzos in the ICU (MDZ)'
label(endo.data.desc$mean.op.new.icu) <- 'Mean 24h opioids in the ICU (fentanyl)'
label(endo.data.desc$mean.prop.icu) <- 'Mean 24h propofol in the ICU'
label(endo.data.desc$mean.dex.icu) <- 'Mean 24h dex in the ICU'
label(endo.data.desc$mean.hal.icu) <- 'Mean 24h haldol in the ICU'
label(endo.data.desc$cvsofa.day1) <- 'Cardiovasulcar SOFA score, study day 1'
label(endo.data.desc$sevsepsis.day1) <- 'Severely septic, study day 1'
label(endo.data.desc$ever.vent.s) <- 'Ever on MV during study period'
label(endo.data.desc$vent.los.tot.eo) <- 'Time on MV among exposed'
label(endo.data.desc$ever.del.s.imp) <- 'Ever delirious during study period'
label(endo.data.desc$del.s.imp.eo) <- 'Days of delirium among exposed'
label(endo.data.desc$ever.coma.s.imp) <- 'Ever comatose during study period'
label(endo.data.desc$coma.s.imp.eo) <- 'Days of coma among exposed'
label(endo.data.desc$ever.sevseptic.s) <- 'Ever severely septic during study period'
label(endo.data.desc$icudays.sevseptic.eo) <- 'Days of severe sepsis among exposed'
label(endo.data.desc$il6.day1) <- 'IL-6, study day 1'
label(endo.data.desc$bdnf.day1) <- 'BDNF, study day 1'
label(endo.data.desc$esel.day1) <- 'E-selectin, study day 1'
label(endo.data.desc$pai1.day1) <- 'PAI-1, study day 1'
label(endo.data.desc$s100b.day1) <- 'S100B, study day 1'
label(endo.data.desc$uchl.day1) <- 'UCHL, study day 1'
label(endo.data.desc$il6.log10) <- 'Log10(IL-6), study day 1'
label(endo.data.desc$bdnf.log10) <- 'Log10(BDNF), study day 1'
label(endo.data.desc$esel.log10) <- 'Log10(E-selectin), study day 1'
label(endo.data.desc$pai1.log10) <- 'Log10(PAI-1), study day 1'
label(endo.data.desc$s100b.log10) <- 'Log10(S100B), study day 1'
label(endo.data.desc$uchl.log10) <- 'Log10(UCHL), study day 1'
label(endo.data.desc$rbans.global.score.3) <- 'RBANS global score, 3m'
label(endo.data.desc$rbans.global.score.12) <- 'RBANS global score, 12m'
label(endo.data.desc$trail.b.tscore.3) <- 'Trails B T-score, 3m'
label(endo.data.desc$trail.b.tscore.12) <- 'Trails B T-score, 12m'
label(endo.data.desc$adl.totscore.3) <- 'ADL score, 3m'
label(endo.data.desc$adl.totscore.12) <- 'ADL score, 12m'
label(endo.data.desc$faq.totscore.3) <- 'FAQ score, 3m'
label(endo.data.desc$faq.totscore.12) <- 'FAQ score, 12m'

@

\section{Descriptive Statistics}
Tables \ref{table:enrollstat} - \ref{table:fustat} present descriptive statistics for the
\Sexpr{length(unique(endo.data$id))} patients with endothelial/BBB injury markers and long-term
followup data. Cohort definitions are as follows:
\begin{itemize}
\item Entire cohort: all patients who had at least one of RBANS global, Trails B, ADL, or FAQ at at
      least one time point \textbf{and} had endothelial/BBB biomarker data
\item Cognitive outcomes: all patients who had at least one of RBANS global or Trails B at at least
      one time point and had endothelial/BBB biomarker data
\item Functional outcomes: all patients who had at least one of ADL or FAQ at at least one time
      point and had endothelial/BBB biomarker data
\end{itemize}

<<printdescstats, results='asis'>>=
latex(summaryM(age.enroll + sex.pp + race.pp + edu + charlson.score + iqcode.score.e + stroke.risk +
                 adl.e + faq.e + disabled.e + frailty + icu.type + admit.dx + num.apache +
                 sofa ~ cohort,
               data = endo.data.desc),
      file = '',
      where = '!h',
      caption = 'Enrollment Characteristics',
      caption.lot = 'Enrollment Characteristics',
      label = 'table:enrollstat',
      digits = 2,
      size = 'small',
      exclude1 = FALSE,
      long = TRUE,
      prmsd = TRUE,
      prn = FALSE,
      what = '%',
      npct = 'both')

latex(summaryM(mean.benz.icu + mean.op.new.icu + mean.prop.icu + mean.dex.icu + mean.hal.icu +
                 ever.vent.s + vent.los.tot.eo + ever.del.s.imp + del.s.imp.eo +
                 ever.coma.s.imp + coma.s.imp.eo + ever.sevseptic.s + icudays.sevseptic.eo +
                 cvsofa.day1 + sevsepsis.day1 ~ cohort,
               data = endo.data.desc),
      file = '',
      where = '!h',
      caption = 'In-Hospital Characteristics',
      caption.lot = 'In-Hospital Characteristics',
      label = 'table:inhospstat',
      digits = 2,
      size = 'footnotesize',
      exclude1 = FALSE,
      long = TRUE,
      prmsd = TRUE,
      prn = FALSE,
      what = '%',
      npct = 'both')

latex(summaryM(il6.day1 + bdnf.day1 + esel.day1 + pai1.day1 + s100b.day1 + uchl.day1 ~ cohort,
               data = endo.data.desc),
      file = '',
      where = '!h',
      caption = 'IL-6 and Endothelial/BBB Marker Characteristics',
      caption.lot = 'IL-6 and Endothelial/BBB Marker Characteristics',
      label = 'table:markerstat',
      digits = 2,
      size = 'footnotesize',
      exclude1 = FALSE,
      long = TRUE,
      prmsd = TRUE,
      prn = FALSE,
      what = '%',
      npct = 'both')

latex(summaryM(rbans.global.score.3 + rbans.global.score.12 + trail.b.tscore.3 +
                 trail.b.tscore.12 + adl.totscore.3 + adl.totscore.12 + faq.totscore.3 +
                 faq.totscore.12 ~ cohort,
               data = endo.data.desc),
      file = '',
      where = '!h',
      caption = 'Followup Outcomes',
      caption.lot = 'Followup Outcomes',
      label = 'table:fustat',
      digits = 2,
      size = 'small',
      exclude1 = FALSE,
      long = TRUE,
      prmsd = TRUE,
      what = '%',
      npct = 'both')

@

\clearpage
<<markerhist>>=
marker.hist.data.org <- endo.data %>%
  select(il6.day1, bdnf.day1, esel.day1, pai1.day1, s100b.day1, uchl.day1) %>%
  gather(key = marker, value = markerval) %>%
  mutate(marker = toupper(gsub('\\.day1$', '', marker)))

marker.hist.data.log10 <- endo.data %>%
  select(il6.log10, bdnf.log10, esel.log10, pai1.log10, s100b.log10, uchl.log10) %>%
  gather(key = marker, value = markerval) %>%
  mutate(marker = toupper(gsub('\\.log10$', '', marker)))

## Function to create histogram of biomarkers on either scale
marker.hist <- function(histdata, xlabel){
  ggplot(aes(x = markerval), data = histdata) +
    facet_wrap(~ marker, scales = 'free_x') +
    geom_histogram(fill = 'navy') +
    xlab(xlabel) +
    ylab('Frequency') +
    theme_bw() +
    theme(axis.text = element_text(colour = 'gray30', size = 8),
          axis.title.x = element_text(vjust = -0.5),
          axis.ticks = element_blank(),
          strip.text = element_text(face = 'bold'))
}

@

<<printmarkerhistorg, results='asis', fig.cap='Histogram of IL-6 and Endothelial Markers, Original Scale', fig.height=4.5, fig.width=8, fig.pos='!h'>>=
marker.hist(marker.hist.data.org, xlabel = 'Endothelial Marker Value, Original Scale')

@

<<printmarkerhistlog10, results='asis', fig.cap='Histogram of IL-6 and Endothelial Markers, Log10 Scale', fig.height=4.5, fig.width=8, fig.pos='!h'>>=
marker.hist(marker.hist.data.log10, xlabel = 'Endothelial Marker Value, Log10 Scale')

@

<<analysisprep>>=
## Get values to interact for age, IL-6
intvals.age <- quantile(endo.data[,'age.enroll'], probs = c(0.25, 0.5, 0.75, 0.9), na.rm = TRUE)
intvals.il6 <- quantile(endo.data[,'il6.log10'], probs = c(0.25, 0.5, 0.75, 0.9), na.rm = TRUE)

## Function to format and round number to the same number of digits
rndformat <- function(val, digits = 2){
  format(round(val, digits), nsmall = digits, big.mark = ',')
}

formatp <- function(val){
  ifelse(val < 0.0001, '<0.0001',
  ifelse(val < 0.001, '<0.001',
         rndformat(val, digits = 3)))
}

## Function to get p-value from lmtest::lrtest()
lrpval <- function(mod1, mod2){
  as.data.frame(lmtest::lrtest(mod1, mod2))[2, 'Pr(>Chisq)']
}

# ## -- Create mice objects to use for multiple imputation for all models ----------------------------
# mice.vars <- c('bdnf.log10', 'esel.log10', 'pai1.log10', 's100b.log10', 'uchl.log10',
#                'age.div10', 'il6.log10', 'charlson.score', 'iqcode.score.e', 'stroke.risk',
#                'edu.div10', 'disabled.e', #'adl.e', 'faq.e',
#                'apache.aps', 'mean.modsofa.icu', 'cvsofa.day1', 'sevsepsis.day1',
#                'icudays.sevseptic.s', 'del.s.imp', 'coma.s.imp',
#                'rbans.global.score.3', 'rbans.global.score.12',
#                'trail.b.tscore.3', 'trail.b.tscore.12',
#                'adl.totscore.3', 'adl.totscore.12',
#                'faq.rdscore.3', 'faq.rdscore.12')
#
# mice.del <- mice(data = endo.data[,mice.vars], m = nimp, seed = 56)
# mice.cog.3 <- mice(data = endo.data[endo.data$cog.cohort.3, mice.vars], m = nimp, seed = 56)
# mice.cog.12 <- mice(data = endo.data[endo.data$cog.cohort.12, mice.vars], m = nimp, seed = 56)
# mice.func.3 <- mice(data = endo.data[endo.data$func.cohort.3, mice.vars], m = nimp, seed = 56)
# mice.func.12 <- mice(data = endo.data[endo.data$func.cohort.12, mice.vars], m = nimp, seed = 56)


# ## -- Function to fit NB model, determine whether 1) nonlinear & 2) interaction terms are needed,
# ## --  and return final model object, p-values for nonlinearity and interactions, and final p for
# ## --  biomarker
# fit.nb.models <- function(use.marker,     ## character string; name of biomarker variable to use
#                           mice.obj,       ## name of mice object
#                           formula.full,   ## formula for full model formula
#                           max.iter = 25,  ## maximum number of iterations for glm.nb()
#                           nomark.list){   ## list of models w/o biomarker, named "lin", "nonlin"
#
#   ## Get actual mice object from character string
#   use.mice <- get(mice.obj)
#
#   ## Function for pool.compare() to save typing
#   pc.jt <- function(mod1, mod2){ pool.compare(mod1, mod2, method = use.method, data = use.mice) }
#
#   ## Initialize all p-values
#   p.nonlin <- p.int <- p.marker <- p.int.age <- p.int.il6 <- NULL
#
#   ## Step 1: Fit full model
#   marker.full.formula <- gsub('markervar', use.marker, formula.full)
#   mod.full <-
#     eval(parse(text = sprintf("with(%s, glm.nb(formula = %s, maxit = %s))",
#                               mice.obj, marker.full.formula, max.iter)))
#
#   ## Step 2: Test for whether nonlinear terms are needed
#   ## 2a. Fit model with all linear terms
#   marker.lin.formula <- gsub(', *[0-9]+\\)', '', gsub('rcs\\(', '', marker.full.formula))
#   mod.lin <-
#     eval(parse(text = sprintf("with(%s, glm.nb(formula = %s, maxit = %s))",
#                               mice.obj, marker.lin.formula, max.iter)))
#
#   ## 2b. Calculate p-value for all nonlinear terms
#   p.nonlin <- pc.jt(mod.full, mod.lin)$pvalue
#
#   ## Step 3: Test for interactions using model with or without nonlinear terms,
#   ##         depending on p.nonlin
#   ## 3a. Determine non-interaction model formula based on p-value for nonlinear terms
#   if(p.nonlin > pcutoff){
#     form.split <- strsplit(marker.lin.formula, ' *\\+ *')[[1]]
#
#     ## 3b. Fit model without interaction terms
#     marker.noint.formula <- paste(form.split[grep(':', form.split, invert = TRUE)],
#                                   collapse = ' + ')
#     mod.noint <-
#       eval(parse(text = sprintf("with(%s, glm.nb(formula = %s, maxit = %s))",
#                                 mice.obj, marker.noint.formula, max.iter)))
#
#     ## 3c. Calculate p-value for all interaction terms
#     p.int <- pc.jt(mod.lin, mod.noint)$pvalue
#
#     ## 3d. Save final model object
#     if(p.int > pcutoff){
#       mod.final <- mod.noint
#     } else{
#       mod.final <- mod.lin
#
#       ## 3e. If p-value for interaction is below cutoff, test age, IL-6 interactions separately
#       marker.noage.formula <- paste(form.split[grep('age\\.enroll.*:', form.split, invert = TRUE)],
#                                     collapse = ' + ')
#       mod.noage <-
#         eval(parse(text = sprintf("with(%s, glm.nb(formula = %s, maxit = %s))",
#                                   mice.obj, marker.noage.formula, max.iter)))
#       p.int.age <- pc.jt(mod.lin, mod.noage)$pvalue
#
#       marker.noil6.formula <- paste(form.split[grep('il6.*:', form.split, invert = TRUE)],
#                                     collapse = ' + ')
#       mod.noil6 <-
#         eval(parse(text = sprintf("with(%s, glm.nb(formula = %s, maxit = %s))",
#                                   mice.obj, marker.noil6.formula, max.iter)))
#       p.int.il6 <- pc.jt(mod.lin, mod.noil6)$pvalue
#     }
#
#     ## 4. Calculate overall p-value for biomarker
#     p.marker <- pc.jt(mod.final, nomark.list$lin)$pvalue
#   } else{
#     form.split <- strsplit(marker.full.formula, ' *\\+ *')[[1]]
#
#     ## 3b. Fit model without interaction terms
#     marker.noint.formula <- paste(form.split[grep(':', form.split, invert = TRUE)],
#                                   collapse = ' + ')
#     mod.noint <-
#       eval(parse(text = sprintf("with(%s, glm.nb(formula = %s, maxit = %s))",
#                                 mice.obj, marker.noint.formula, max.iter)))
#
#     ## 3c. Calculate p-value for all interaction terms
#     p.int <- pc.jt(mod.full, mod.noint)$pvalue
#
#     ## 3d. Save final model object
#     if(p.int > 0.2){
#       mod.final <- mod.noint
#     } else{
#       mod.final <- mod.full
#
#       ## 3e. If p-value for interaction is below cutoff, test age, IL-6 interactions separately
#       marker.noage.formula <- paste(form.split[grep('age\\.enroll.*:',form.split, invert = TRUE)],
#                                     collapse = ' + ')
#       mod.noage <-
#         eval(parse(text = sprintf("with(%s, glm.nb(formula = %s, maxit = %s))",
#                                   mice.obj, marker.noage.formula, max.iter)))
#       p.int.age <- pc.jt(mod.full, mod.noage)$pvalue
#
#       marker.noil6.formula <- paste(form.split[grep('il6.*:', form.split, invert = TRUE)],
#                                     collapse = ' + ')
#       mod.noil6 <-
#         eval(parse(text = sprintf("with(%s, glm.nb(formula = %s, maxit = %s))",
#                                   mice.obj, marker.noil6.formula, max.iter)))
#       p.int.il6 <- pc.jt(mod.full, mod.noil6)$pvalue
#     }
#
#     ## 4. Calculate overall p-value for biomarker
#     p.marker <- pc.jt(mod.final, nomark.list$nonlin)$pvalue
#   }
#
#   return(list('final.mod' = mod.final,
#               'p.nonlin' = p.nonlin,
#               'p.int' = p.int,
#               'p.int.age' = p.int.age,
#               'p.int.il6' = p.int.il6,
#               'p.marker' = p.marker))
# }

## -- Function to update zero-inflated formulas given a count, zero portion and a regex ------------
create.zeroinfl.form <- function(count.form, zero.form, regex.sub){
  paste(paste(count.form[grep(regex.sub, count.form, invert = TRUE)], collapse = ' + '),
        paste(zero.form[grep(regex.sub, zero.form, invert = TRUE)], collapse = ' + '),
        sep = ' | ')
}

## -- Function to fit zero-inflated, NB, or linear model;
## --  determine whether 1) nonlinear and 2) interaction terms are needed, and
## --  return final model object, p-values for nonlinearity and interactions,
## --  and final p for biomarker
fit.reg.models <- function(use.marker,   ## character string; name of biomarker variable
                           formula.full, ## formula for full model formula
                           modtype = c('nb', 'zeroinfl', 'ols'), ## Model type to use
                           dataset = endo.data){ ## original data set to use

  if(modtype == 'nb'){
    modfit.text = "glm.nb(formula = %s, data = usedata)"
  } else if(modtype == 'zeroinfl'){
    modfit.text = "zeroinfl(formula = %s, data = usedata, dist = 'negbin')"
  } else if(modtype == 'ols'){
    modfit.text = "ols(formula = %s, data = usedata)"
  }
  
  ## Initialize all p-values
  p.nonlin <- p.int <- p.marker <- p.int.age <- p.int.il6 <- NULL

  ## Does full model have nonlinear terms?
  has.rcs <- length(grep('rcs(', formula.full, fixed = TRUE)) > 0

  ## Step 1: Create data set with complete data from initial dataset object
  ## Get variables in formula.full
  modvars <- gsub('rcs\\(', '', strsplit(formula.full, ' *[~+] *')[[1]])
  modvars <- unique(gsub(', [0-9]\\)', '', modvars[grep(':', modvars, invert = TRUE)]))
  modvars <- gsub('markervar', use.marker, modvars)
  usedata <- dataset[rowSums(is.na(dataset[,modvars])) == 0,]

  ## Step 2: Fit full model
  marker.full.formula <- gsub('markervar', use.marker, formula.full)
  mod.full <-
    eval(parse(text = sprintf(modfit.text, marker.full.formula)))

  ## Step 3: Test for whether nonlinear terms are needed
  if(has.rcs){
    ## 3a. Fit model with all linear terms
    marker.lin.formula <- gsub(', *[0-9]+\\)', '', gsub('rcs\\(', '', marker.full.formula))
    mod.lin <- eval(parse(text = sprintf(modfit.text, marker.lin.formula)))

    ## 3b. Calculate p-value for all nonlinear terms
    p.nonlin <- lrpval(mod.full, mod.lin)
  } else{
    marker.lin.formula <- marker.full.formula
    mod.lin <- mod.full
  }

  ## Step 4: Test for interactions, using model with or w/o nonlinear terms, depending on p.nonlin
  ## 4a. Determine non-interaction model formula based on p-value for nonlinear terms
  if(is.null(p.nonlin) || p.nonlin > pcutoff){
    if(modtype == 'zeroinfl'){
      ## Split twice for zero-inflated: once for count vs. zero portion, once to get each variable
      form.split <- strsplit(marker.lin.formula, '|', fixed = TRUE)
      form.split.count <- strsplit(form.split[[1]][1], ' *\\+ *')[[1]]
      form.split.zero <- strsplit(form.split[[1]][2], ' *\\+ *')[[1]]
      
      marker.noint.formula <- create.zeroinfl.form(count.form = form.split.count,
                                                   zero.form = form.split.zero,
                                                   regex.sub = ':')
    } else{
      form.split <- strsplit(marker.lin.formula, ' + ', fixed = TRUE)[[1]]
      marker.noint.formula <-
        paste(form.split[grep(':', form.split, invert = TRUE)], collapse = ' + ')
    }

    ## 4b. Fit model without interaction terms
    mod.noint <- eval(parse(text = sprintf(modfit.text, marker.noint.formula)))

    ## 4c. Calculate p-value for all interaction terms
    p.int <- lrpval(mod.lin, mod.noint)

    ## 4d. Save final model object
    if(p.int > pcutoff){
      mod.final <- mod.noint
    } else{
      mod.final <- mod.lin

      ## 4e. If p-value for interaction is below cutoff, test age, IL-6 interactions separately
      if(modtype == 'zeroinfl'){
        marker.noage.formula <- create.zeroinfl.form(count.form = form.split.count,
                                                     zero.form = form.split.zero,
                                                     regex.sub = 'age\\.[enroll | div10].*:')
        marker.noil6.formula <- create.zeroinfl.form(count.form = form.split.count,
                                                     zero.form = form.split.zero,
                                                     regex.sub = 'il6.log10.*:')
      } else{
        marker.noage.formula <- paste(form.split[grep('age\\.[enroll | div10].*:',
                                                      form.split, invert = TRUE)],
                                      collapse = ' + ')
        marker.noil6.formula <- paste(form.split[grep('il6.log10.*:', form.split, invert = TRUE)],
                                      collapse = ' + ')
      }
      mod.noage <- eval(parse(text = sprintf(modfit.text, marker.noage.formula)))
      p.int.age <- lrpval(mod.lin, mod.noage)

      mod.noil6 <- eval(parse(text = sprintf(modfit.text, marker.noil6.formula)))
      p.int.il6 <- lrpval(mod.lin, mod.noil6)
    }
  } else{
    if(modtype == 'zeroinfl'){
      ## Split twice: once for count vs. zero portion, once to get each variable
      form.split <- strsplit(marker.full.formula, '|', fixed = TRUE)
      form.split.count <- strsplit(form.split[[1]][1], ' *\\+ *')[[1]]
      form.split.zero <- strsplit(form.split[[1]][2], ' *\\+ *')[[1]]
      
      ## 4b. Fit model without interaction terms
      marker.noint.formula <- create.zeroinfl.form(count.form = form.split.count,
                                                   zero.form = form.split.zero,
                                                   regex.sub = ':')
    } else{
      form.split <- strsplit(marker.full.formula, ' + ', fixed = TRUE)[[1]]
      marker.noint.formula <-
        paste(form.split[grep(':', form.split, invert = TRUE)], collapse = ' + ')
    }
    mod.noint <- eval(parse(text = sprintf(modfit.text, marker.noint.formula)))

    ## 4c. Calculate p-value for all interaction terms
    p.int <- lrpval(mod.full, mod.noint)

    ## 4d. Save final model object
    if(p.int > 0.2){
      mod.final <- mod.noint
    } else{
      mod.final <- mod.full

      if(modtype == 'zeroinfl'){
        marker.noage.formula <- create.zeroinfl.form(count.form = form.split.count,
                                                     zero.form = form.split.zero,
                                                     regex.sub = 'age\\.[enroll | div10].*:')
        marker.noil6.formula <- create.zeroinfl.form(count.form = form.split.count,
                                                     zero.form = form.split.zero,
                                                     regex.sub = 'il6.log10.*:')
      } else{
        marker.noage.formula <- paste(form.split[grep('age\\.[enroll | div10].*:',
                                                      form.split, invert = TRUE)],
                                      collapse = ' + ')
        marker.noil6.formula <- paste(form.split[grep('il6.log10.*:', form.split, invert = TRUE)],
                                      collapse = ' + ')
      }
      
      mod.noage <- eval(parse(text = sprintf(modfit.text, marker.noage.formula)))
      p.int.age <- lrpval(mod.full, mod.noage)

      mod.noil6 <- eval(parse(text = sprintf(modfit.text, marker.noil6.formula)))
      p.int.il6 <- lrpval(mod.full, mod.noil6)
    }
  }

  ## 5. Calculate overall p-value for biomarker
  ## 5a. Fit model without any biomarker terms, using same data set
  final.call <- as.character(mod.final$call)[2]
  if(modtype == 'zeroinfl'){
    ## Split twice: once for count vs. zero portion, once to get each variable
    final.call.split <- strsplit(final.call, '|', fixed = TRUE)
    final.call.count <- strsplit(final.call.split[[1]][1], ' *\\+ *')[[1]]
    final.call.zero <- strsplit(final.call.split[[1]][2], ' *\\+ *')[[1]]
    nomark.form <- create.zeroinfl.form(count.form = final.call.count,
                                        zero.form = final.call.zero,
                                        regex.sub = use.marker)
  } else{
    final.call.split <- strsplit(final.call, ' + ', fixed = TRUE)[[1]]
    nomark.form <- paste(final.call.split[grep(use.marker, final.call.split, invert = TRUE)],
                         collapse = ' + ')
  }
  nomark.mod <- eval(parse(text = sprintf(modfit.text, nomark.form)))

  p.marker <- lrpval(mod.final, nomark.mod)

  return(list('final.mod' = mod.final,
              'p.nonlin' = p.nonlin,
              'p.int' = p.int,
              'p.int.age' = p.int.age,
              'p.int.il6' = p.int.il6,
              'p.marker' = p.marker))
}

## -- Need to calculate predicted values for NB models by hand -------------------------------------
## Function to get median from endo.data$variable
get.med <- function(varname){ median(endo.data[,varname], na.rm = TRUE) }

## Function to calculate spline term for median of a variable in endo.data
get.med.spline <- function(varname){
  startval <- median(endo.data[,varname], na.rm = TRUE)
  useknots <- rcspline.eval(endo.data[,varname], nk = 3, knots.only = TRUE)
  calc.spline(startval, k1 = useknots[1], k2 = useknots[2], k3 = useknots[3])
}

## Function to get 2.5th, 97.5th percentiles
get.ci <- function(x){ quantile(x, probs = c(0.025, 0.975), na.rm = TRUE) }

## -- Function to create design matrix given a mice model object, X and interacting variables ------
catvars <- "sevsepsis.day1"
# create.designmat.mice <- function(miceobj,              ## mice model object
#                                   xvar,                 ## string; variable for x axis
#                                   intvar = NULL,        ## string; variable to interact
#                                   intvals = NULL,       ## vector; values to set int. variable to
#                                   dataset = endo.data){ ## data frame to get unique X values from
#
#   ## miceobj must be of class mice
#   if(length(grep('mira', class(miceobj))) == 0){
#     stop('miceobj must be of class mira from mice library')
#   } else if(!is.null(intvar) & length(grep(':', names(miceobj$analyses[[1]]$coefficients))) == 0){
#     stop('Interacting variable is specified, but model does not include interaction terms')
#   } else if(!is.null(intvar) & is.null(intvals)){
#     stop('Interacting variable is specified, but no interacting values are specified')
#   } else{
#
#     ## Get coefficient names. Categorical variables have a number on the end; strip that, "rcs(...)"
#     coefnames <- unlist(lapply(names(miceobj$analyses[[1]]$coefficients),
#                                FUN = function(x){
#                                  tmp1 <- gsub("rcs\\([a-z.,0-9 ]+\\)", "", x)
#                                  tmp2 <- gsub('.$', '', x)
#                                  if(tmp2 %in% catvars){ tmp2 } else{ tmp1 }
#                                }))
#
#     ## Get unique values of variable on X axis
#     xvals <- sort(unique(dataset[,xvar]))
#     xknots <- rcspline.eval(xvals, nk = 3, knots.only = TRUE)
#     xvals <- xvals[xvals >= xknots[1] & xvals <= xknots[3]]
#     if(length(grep(paste0(xvar, "'"), coefnames)) > 0){
#       xvals.spline <- unlist(lapply(xvals,
#                                     FUN = calc.spline,
#                                     k1 = xknots[1], k2 = xknots[2], k3 = xknots[3]))
#     }
#
#     ## Set values for all non-interaction columns
#     coefs.noint <- coefnames[grep(':', coefnames, invert = TRUE)]
#     coefs.int <- coefnames[grep(':', coefnames)]
#
#     predmat.noint <- do.call(cbind,
#                          lapply(coefs.noint, FUN = function(name){
#                            if(name == '(Intercept)'){
#                              rep(1, length(xvals))
#                            } else if(name == xvar){
#                              xvals
#                            } else if(name == paste0(xvar, "'")){
#                              xvals.spline
#                            } else if(name %in% c(intvar, paste0(intvar, "'"))){
#                              rep(NA, length(xvals))
#                            } else if(name %in% catvars){
#                              rep(0, length(xvals))
#                            } else if(length(grep("'", name)) == 0){
#                              get.med(name)
#                            } else{
#                              get.med.spline(gsub('.$', '', name))
#                            }
#                          }))
#     colnames(predmat.noint) <- coefs.noint
#
#     ## If there is an interacting variable, repeat predmat.noint x number of unique values, then
#     ##  fill in NA columns with unique values
#     if(!is.null(intvar)){
#       predmat.noint <- do.call(rbind,
#                                replicate(length(intvals), predmat.noint, simplify = FALSE))
#       predmat.noint[,intvar] <- unlist(lapply(intvals, FUN = function(x){ rep(x, length(xvals)) }))
#
#       ## If interacting variable is nonlinear, determine knots for spline term
#       if(length(grep(paste0(intvar, "'"), coefnames)) > 0){
#         intknots <- rcspline.eval(dataset[,intvar], nk = 3, knots.only = TRUE)
#         intspline <- unlist(lapply(intvals,
#                                    FUN = calc.spline,
#                                    k1 = intknots[1], k2 = intknots[2], k3 = intknots[3]))
#         predmat.noint[,paste0(intvar, "'")] <-
#           unlist(lapply(intspline, FUN = function(x){ rep(x, length(xvals)) }))
#       }
#     }
#
#     if(length(coefs.int) > 0){
#       predmat.int <- do.call(cbind,
#                              lapply(coefs.int, FUN = function(name){
#                                tmp <- strsplit(name, ':')[[1]]
#                                predmat.noint[,tmp[1]] * predmat.noint[,tmp[2]]
#                              }))
#       colnames(predmat.int) <- coefs.int
#       predmat <- cbind(predmat.noint, predmat.int)[,coefnames]
#     } else{
#       predmat <- predmat.noint[,coefnames]
#     }
#   }
#
#   return(predmat)
#
# }

## -- Function to create design matrices given a glm.nb object, X & interacting variables ---------
create.designmat.nb <- function(nbobj,                ## glm.nb model object
                                xvar,                 ## string; variable for x axis
                                intvar = NULL,        ## string; variable to interact
                                intvals = NULL,       ## vector; values to set int. variable to
                                dataset = endo.data){ ## data frame to get unique X values from

  ## miceobj must be of class zeroinfl
  if(length(grep('negbin', class(nbobj))) == 0){
    stop('nbobj must be of class negbin from glm.nb()')
  } else if(!is.null(intvar) & length(grep(':', names(coef(nbobj)))) == 0){
    stop('Interacting variable is specified, but model does not include interaction terms')
  } else if(!is.null(intvar) & is.null(intvals)){
    stop('Interacting variable is specified, but no interacting values are specified')
  } else{

    ## Get coefficient names for count and zero portions
    coefnames <- names(coef(nbobj))

    ## Strip out "rcs(...)" and "count_/zero_"
    coefnames2 <- unlist(lapply(coefnames, FUN = function(x){
      tmp1 <- gsub("rcs\\([a-z.,0-9 ]+\\)", "", x)
      ## try pmatch(): res <- catvars[which(!is.na(pmatch(catvars, x)))]
      if(sum(!is.na(pmatch(catvars, tmp1))) > 0){
        tmp2 <- catvars[which(!is.na(pmatch(catvars, tmp1)))]
      } else{ tmp2 <- tmp1 }
      tmp2
    }))

    ## Get unique values of variable on X axis
    xvals <- sort(unique(dataset[,xvar]))
    xknots <- rcspline.eval(xvals, nk = 3, knots.only = TRUE)
    xvals <- xvals[xvals >= xknots[1] & xvals <= xknots[3]]
    if(length(grep(paste0(xvar, "'"), coefnames2)) > 0){
      xvals.spline <- unlist(lapply(xvals,
                                    FUN = calc.spline,
                                    k1 = xknots[1], k2 = xknots[2], k3 = xknots[3]))
    }

    ## Set values for all non-interaction columns
    coefs.noint <- coefnames2[grep(':', coefnames2, invert = TRUE)]
    coefs.int <- coefnames2[grep(':', coefnames2)]

    ## Function to fill in non-interaction columns
    fill.predvals.noint <- function(name){
      if(name == '(Intercept)'){
        rep(1, length(xvals))
      } else if(name == xvar){
        xvals
      } else if(name == paste0(xvar, "'")){
        xvals.spline
      } else if(!is.null(intvar) & name %in% c(intvar, paste0(intvar, "'"))){
        rep(NA, length(xvals))
      } else if(name %in% catvars){
        rep(0, length(xvals))
      } else if(length(grep("'", name)) == 0){
        get.med(name)
      } else{
        get.med.spline(gsub('.$', '', name))
      }
    }

    predmat.noint <- do.call(cbind, lapply(coefs.noint, FUN = fill.predvals.noint))
    colnames(predmat.noint) <- coefs.noint

    ## If there is an interacting variable, repeat predmat.noint x number of unique values, then
    ##  fill in NA columns with unique values
    if(!is.null(intvar)){
      predmat.noint <-
        do.call(rbind, replicate(length(intvals), predmat.noint, simplify = FALSE))
      if(intvar %in% colnames(predmat.noint)){
        predmat.noint[,intvar] <-
          unlist(lapply(intvals, FUN = function(x){ rep(x, length(xvals)) }))
      }

      ## If interacting variable is nonlinear, determine knots for spline term
      if(length(grep(paste0(intvar, "'"), coefnames2)) > 0){
        intknots <- rcspline.eval(dataset[,intvar], nk = 3, knots.only = TRUE)
        intspline <- unlist(lapply(intvals,
                                   FUN = calc.spline,
                                   k1 = intknots[1], k2 = intknots[2], k3 = intknots[3]))
        predmat.noint[,paste0(intvar, "'")] <-
          unlist(lapply(intspline, FUN = function(x){ rep(x, length(xvals)) }))
      }
    }

    if(length(coefs.int) > 0){
      predmat.int <- do.call(cbind,
                             lapply(coefs.int, FUN = function(name){
                               tmp <- strsplit(name, ':')[[1]]
                               predmat.noint[,tmp[1]] * predmat.noint[,tmp[2]]
                             }))
      colnames(predmat.int) <- coefs.int
      predmat <- cbind(predmat.noint, predmat.int)[,coefnames2]
    } else{
      predmat <- predmat.noint[,coefnames2]
    }
  }

  return('predmat' = predmat)

}

## -- Function to, for each row in design matrix, calculate predicted value & SE from negbin model
calc.nbresults <- function(nbobj,          ## negbin model object (from glm.nb())
                           designmat,      ## matrix of covariate values; ncols = coefs in nbobj
                           xvar,           ## character string: name of variable to put on X axis
                           intvar = NULL){ ## character string: name of interacting variable

  if(length(grep('negbin', class(nbobj))) == 0){
    stop("nbobj must be of class negbin, from glm.nb()")
  } else if(ncol(designmat) != length(names(coef(nbobj)))){
    stop("Number of columns in design matrix does not match number of coefficients in nbobj")
  } else if(xvar %nin% colnames(designmat)){
    stop("X axis variable name not in column names of design matrix")
  } else{
    ## Get coefficients and vcov matrix
    nb.coefs <- coef(nbobj)
    nb.vcov <- vcov(nbobj)

    ## Calculate linear predictors and their SEs
    lp <- apply(designmat, MARGIN = 1, FUN = function(x){ sum(nb.coefs * as.numeric(x)) })
    lp.se <- apply(designmat, MARGIN = 1, FUN = function(x){ sqrt(t(x) %*% nb.vcov %*% x) })

    ## Calculate LCL, UCLs for linear predictors
    lp.lcl <- lp - qnorm(0.975)*lp.se
    lp.ucl <- lp + qnorm(0.975)*lp.se

    ## Calculate predicted counts, CIs as exp(quantities)
    count.pe <- exp(lp)
    count.lcl <- exp(lp.lcl)
    count.ucl <- exp(lp.ucl)

    ## Bind all results into data frame for plotting
    xvalue <- designmat[,xvar]
    if(!is.null(intvar)){
      intvalue <- designmat[,intvar]
      return(as.data.frame(cbind(xvalue, intvalue, lp, lp.se, count.pe, count.lcl, count.ucl)))
    } else{
      return(as.data.frame(cbind(xvalue, lp, lp.se, count.pe, count.lcl, count.ucl)))
    }
  }
}

## -- Function to plot results of negative binomial models -----------------------------------------
plot.nb.results <- function(nbobj,            ## list, result of fit.reg.models()
                            xvar,             ## string, name of X axis variable
                            intvar = NULL,    ## string, name of interacting variable
                            intvals = NULL,   ## vector, levels to set interacting variable to
                            intstring = NULL, ## string, text for panel titles and X axis label
                            intp = NULL,      ## number, p-value for specific interaction
                            xstring,          ## string, label of X axis variable
                            ystring){         ## string, label of outcome

  if(length(grep('final\\.mod', names(nbobj))) == 0){
    stop("Argument nbobj should be a result of fit.reg.models()")
  } else if(!is.null(intvar) & length(grep(':', names(coef(nbobj$final.mod)))) == 0){
    stop('Interacting variable is specified, but model does not include interaction terms')
  } else if(!is.null(intvar) & is.null(intvals)){
    stop('Interacting variable is specified, but no interacting values are specified')
  } else{
    if(is.null(intvar)){
      nb.designmat <- create.designmat.nb(nbobj = nbobj$final.mod, xvar = xvar)
      nb.results <- calc.nbresults(nbobj = nbobj$final.mod, designmat = nb.designmat, xvar = xvar)
    } else{
      nb.designmat <- create.designmat.nb(nbobj = nbobj$final.mod, xvar = xvar,
                                          intvar = intvar, intvals = intvals)

      nb.results <- calc.nbresults(nbobj = nbobj$final.mod, designmat = nb.designmat,
                                   xvar = xvar, intvar = intvar)

      nb.results$intvalue.f <-
        with(nb.results, factor(paste(intstring, '=', rndformat(intvalue, 2))))
    }

    nb.plot <- ggplot(aes(x = xvalue, y = count.pe), data = nb.results) +
      geom_ribbon(aes(ymin = count.lcl, ymax = count.ucl), alpha = 0.3, fill = 'navy') +
      geom_line(colour = 'navy') +
      xlab(sprintf('Log10(%s)\n\nP for biomarker, final model: %s\nP for all interactions: %s',
                   xstring, formatp(nbobj$p.marker), formatp(nbobj$p.int))) +
      ylab(paste('Adjusted', ystring)) +
      theme_bw() +
      theme(axis.title.x = element_text(vjust = 0), #face = 'bold', vjust = 0),
            axis.text = element_text(size = 7),
            strip.text = element_text(face = 'bold'))

    if(is.null(intvar)){
      return(nb.plot +
               xlab(sprintf('Log10(%s)\n\nP for biomarker, final model: %s\nP for global nonlinearity: %s\nP for all interactions: %s',
                            xstring, formatp(nbobj$p.marker),
                            formatp(nbobj$p.nonlin),
                            formatp(nbobj$p.int))))
    } else{
      return(nb.plot +
               facet_wrap(~ intvalue.f, nrow = 1) +
               xlab(sprintf('Log10(%s)\n\nP for biomarker, final model: %s\nP for global nonlinearity: %s\nP for all interactions: %s\nP for %s interaction: %s',
                            xstring, formatp(nbobj$p.marker), formatp(nbobj$p.nonlin),
                            formatp(nbobj$p.int), intstring, formatp(intp))))
    }
  }
}


## -- Function to create design matrices for count, zero portions given a zeroinfl object, ---------
## --  X & interacting variables -------------------------------------------------------------------
create.designmat.zinf <- function(modobj,               ## zeroinfl model object
                                  xvar,                 ## string; variable for x axis
                                  intvar = NULL,        ## string; variable to interact
                                  intvals = NULL,       ## vector; values to set int. variable to
                                  dataset = endo.data){ ## data frame to get unique X values from

  ## miceobj must be of class zeroinfl
  if(length(grep('zeroinfl', class(modobj))) == 0){
    stop('modobj must be of class zeroinfl from pscl library')
  } else if(!is.null(intvar) & length(grep(':', names(coef(modobj)))) == 0){
    stop('Interacting variable is specified, but model does not include interaction terms')
  } else if(!is.null(intvar) & is.null(intvals)){
    stop('Interacting variable is specified, but no interacting values are specified')
  } else{

    ## Get coefficient names for count and zero portions
    coefnames <- names(coef(modobj))
    coefs.c <- coefnames[grep('^count', coefnames)]
    coefs.z <- coefnames[grep('^zero', coefnames)]

    ## Strip out "rcs(...)" and "count_/zero_"
    coefs.c <- unlist(lapply(coefs.c, FUN = function(x){
      tmp1 <- gsub("rcs\\([a-z.,0-9 ]+\\)", "", x)
      tmp2 <- gsub('.$', '', x)
      if(tmp2 %in% catvars){ gsub('^count_', '', tmp2) } else{ gsub('^count_', '', tmp1) }
    }))
    coefs.z <- unlist(lapply(coefs.z, FUN = function(x){
      tmp1 <- gsub("rcs\\([a-z.,0-9 ]+\\)", "", x)
      tmp2 <- gsub('.$', '', x)
      if(tmp2 %in% catvars){ gsub('^zero_', '', tmp2) } else{ gsub('^zero_', '', tmp1) }
    }))

    ## Get unique values of variable on X axis
    xvals <- sort(unique(dataset[,xvar]))
    xknots <- rcspline.eval(xvals, nk = 3, knots.only = TRUE)
    xvals <- xvals[xvals >= xknots[1] & xvals <= xknots[3]]
    if(length(grep(paste0(xvar, "'"), coefnames)) > 0){
      xvals.spline <- unlist(lapply(xvals,
                                    FUN = calc.spline,
                                    k1 = xknots[1], k2 = xknots[2], k3 = xknots[3]))
    }

    ## Set values for all non-interaction columns
    coefs.noint.c <- coefs.c[grep(':', coefs.c, invert = TRUE)]
    coefs.int.c <- coefs.c[grep(':', coefs.c)]
    coefs.noint.z <- coefs.z[grep(':', coefs.z, invert = TRUE)]
    coefs.int.z <- coefs.z[grep(':', coefs.z)]

    ## Function to fill in non-interaction columns
    fill.predvals.noint <- function(name){
      if(name == '(Intercept)'){
        rep(1, length(xvals))
      } else if(name == xvar){
        xvals
      } else if(name == paste0(xvar, "'")){
        xvals.spline
      } else if(!is.null(intvar) & name %in% c(intvar, paste0(intvar, "'"))){
        rep(NA, length(xvals))
      } else if(name %in% catvars){
        rep(0, length(xvals))
      } else if(length(grep("'", name)) == 0){
        get.med(name)
      } else{
        get.med.spline(gsub('.$', '', name))
      }
    }

    predmat.noint.c <- do.call(cbind, lapply(coefs.noint.c, FUN = fill.predvals.noint))
    colnames(predmat.noint.c) <- coefs.noint.c

    predmat.noint.z <- do.call(cbind, lapply(coefs.noint.z, FUN = fill.predvals.noint))
    colnames(predmat.noint.z) <- coefs.noint.z

    ## If there is an interacting variable, repeat predmat.noint x number of unique values, then
    ##  fill in NA columns with unique values
    if(!is.null(intvar)){
      predmat.noint.c <-
        do.call(rbind, replicate(length(intvals), predmat.noint.c, simplify = FALSE))
      if(intvar %in% colnames(predmat.noint.c)){
        predmat.noint.c[,intvar] <-
          unlist(lapply(intvals, FUN = function(x){ rep(x, length(xvals)) }))
      }

      predmat.noint.z <-
        do.call(rbind, replicate(length(intvals), predmat.noint.z, simplify = FALSE))
      if(intvar %in% colnames(predmat.noint.z)){
        predmat.noint.z[,intvar] <-
          unlist(lapply(intvals, FUN = function(x){ rep(x, length(xvals)) }))
      }

      ## If interacting variable is nonlinear, determine knots for spline term
      if(length(grep(paste0(intvar, "'"), coefnames)) > 0){
        intknots <- rcspline.eval(dataset[,intvar], nk = 3, knots.only = TRUE)
        intspline <- unlist(lapply(intvals,
                                   FUN = calc.spline,
                                   k1 = intknots[1], k2 = intknots[2], k3 = intknots[3]))
        if(length(grep(paste0(intvar, "'"), coefs.c)) > 0){
          predmat.noint.c[,paste0(intvar, "'")] <-
            unlist(lapply(intspline, FUN = function(x){ rep(x, length(xvals)) }))
        }

        if(length(grep(paste0(intvar, "'"), coefs.z)) > 0){
          predmat.noint.z[,paste0(intvar, "'")] <-
            unlist(lapply(intspline, FUN = function(x){ rep(x, length(xvals)) }))
        }
      }
    }

    if(length(coefs.int.c) > 0){
      predmat.int.c <- do.call(cbind,
                               lapply(coefs.int.c, FUN = function(name){
                                 tmp <- strsplit(name, ':')[[1]]
                                 predmat.noint.c[,tmp[1]] * predmat.noint.c[,tmp[2]]
                               }))
      colnames(predmat.int.c) <- coefs.int.c
      predmat.c <- cbind(predmat.noint.c, predmat.int.c)[,coefs.c]
    } else{
      predmat.c <- predmat.noint.c[,coefs.c]
    }

    if(length(coefs.int.z) > 0){
      predmat.int.z <- do.call(cbind,
                               lapply(coefs.int.z, FUN = function(name){
                                 tmp <- strsplit(name, ':')[[1]]
                                 predmat.noint.z[,tmp[1]] * predmat.noint.z[,tmp[2]]
                               }))
      colnames(predmat.int.z) <- coefs.int.z
      predmat.c <- cbind(predmat.noint.z, predmat.int.z)[,coefs.z]
    } else{
      predmat.z <- predmat.noint.z[,coefs.z]
    }

  }

  return(list('predmat.c' = predmat.c, 'predmat.z' = predmat.z))

}

## -- Function to get predicted response values from a zero-inflated NB model ----------------------
zinf.response <- function(modobj,       ## Original model object
                          design.zinf){ ## List of design matrices
  ## Get coefficient estimates from modobj, split into count and zero portions
  mod.coefs <- coef(modobj)
  coefs.c <- mod.coefs[grep('^count_', names(mod.coefs))]
  coefs.z <- mod.coefs[grep('^zero_', names(mod.coefs))]

  ## Get linear predictors for count, zero portions
  lp.c <- apply(design.zinf$predmat.c,
                MARGIN = 1,
                FUN = function(x){ sum(x * coefs.c) })
  lp.z <- apply(design.zinf$predmat.z,
                MARGIN = 1,
                FUN = function(x){ sum(x * coefs.z) })

  ## Get point estimates for each unique value of marker
  ## exp(LPc) * (1 - (exp(LPz) / (1 + exp(LPz))))
  pred.response <- exp(lp.c) * (1 - (exp(lp.z) / (1 + exp(lp.z))))

  pred.response
}


try.zeroinfl <- function(...){
  op <- options(warn = 2)
  on.exit(options(op))
  try(zeroinfl(...), silent = TRUE)
}


## -- Function to get data sets of predicted values for plotting zero-inflated NB models -----------
zinf.plotdata <- function(modobj,               ## Original model object to base bootstraps on
                          xvar,                 ## Main exposure variable
                          bootdata,             ## List of bootstrapped data sets to use
                          n.boot = n.bootsets){ ## Number of successful model fits required
  ## Does model include age/IL-6 interactions?
  intmod <- (length(grep(':', modobj$call)) > 0)

  ## Step 1: Create design matrices
  if(intmod){
    intvars <- c('age.div10', 'il6.log10')
    design.age <-
      create.designmat.zinf(modobj, xvar, intvar = 'age.div10', intvals = intvals.age / 10)
    design.il6 <-
      create.designmat.zinf(modobj, xvar, intvar = 'il6.log10', intvals = intvals.il6)
    design.all <- list(design.age, design.il6)
  } else{
    design.all <- list(create.designmat.zinf(modobj, xvar))
  }

  ## Step 2: Get point estimates from main model for each design matrix
  pointests <- lapply(design.all, FUN = function(dmat){
    zinf.response(modobj, dmat)
  })

  ## Step 3: Get predicted values for each bootstrapped data set, using model call in modobj
  formula.final <- as.character(modobj$call)[2]

  mod.list <- vector('list', n.boot)
  n.succ <- n.fail <- 0

  iter <- 1
  while(n.succ < n.boot){
    cur.model <- do.call(try.zeroinfl,
                         list(formula = as.formula(formula.final),
                              dist = 'negbin',
                              data = bootdata[[iter]]))

    ## Did model have an error/warning? Or does it have more/fewer coefs than original?
    curmod.failed <- inherits(cur.model, 'try-error')

    if(curmod.failed){
      n.fail <- n.fail + 1
      ## With first failure, begin a text file to store error messages; with following failues,
      ##  add subsequent errors to it
      if(n.fail == 1){ append.txt <- TRUE } else{ append.txt <- FALSE }

      sink(file = paste('zeroinfl_errors_', xvar, '.txt', sep = ''), append = append.txt)
      cat('Errors and warnings for ', xvar, '\n\nFailure ', n.fail, ': ', cur.model[1], '\n',
          sep = '')
      sink()
    ## Otherwise, increment # successes, save model fit, coefficients, SEs, LR test if needed
    } else{
      n.succ <- n.succ + 1
      mod.list[[n.succ]] <- cur.model
    }

    print(paste("Finished bootstrap iteration", iter, "for", xvar))
    iter <- iter + 1
  }

  pred.all <- lapply(design.all, FUN = function(dmat){
    do.call(cbind,
            lapply(1:length(mod.list), FUN = function(mod){
              cat('Starting model predictions for model', mod, 'of', length(mod.list), '\n')
              zinf.response(mod.list[[mod]], dmat)
            }))
  })

  ## Step 4: Get CIs for each row of the design matrix
  pred.cis <- lapply(pred.all, FUN = function(pmat){
    t(apply(pmat, MARGIN = 1, FUN = get.ci))
  })

  ## Step 5: combine with original xvar, interacting value and point estimate
  if(intmod){
    pred.final <- lapply(1:length(design.all), FUN = function(dmat){
      tmp <- as.data.frame(cbind(design.all[[dmat]]$predmat.c[,c(xvar, intvars[dmat])],
                                 pointests[[dmat]],
                                 pred.cis[[dmat]]))
      names(tmp) <- c(xvar, intvars[dmat], 'pe', 'lcl', 'ucl')
      tmp
    })
  } else{
    pred.final <- lapply(1:length(design.all), FUN = function(dmat){
      tmp <- as.data.frame(cbind(design.all[[dmat]]$predmat.c[,xvar],
                                 pointests[[dmat]],
                                 pred.cis[[dmat]]))
      names(tmp) <- c(xvar, 'pe', 'lcl', 'ucl')
      tmp
    })
  }

  return(list('pred.data' = pred.final, 'n.fail' = n.fail))

}

## -- Function to plot zero-inflated results -------------------------------------------------------
plot.zinf.results <- function(zinfobj,
                              preddata,
                              xvar,
                              xstring,
                              ystring,
                              intvar = NULL,
                              intvar.str = NULL,
                              intvar.p){

  ## Create factor version of interacting variable
  if(!is.null(intvar)){
    preddata$intvar.f <-
      factor(paste(intvar.str, rndformat(preddata[,intvar], digits = 2), sep = ' = '))
  }

  ## Substitute "xvar" for actual name of xvar for ggplot purposes
  names(preddata) <- gsub(xvar, 'xvar', names(preddata))

  zinf.plot <- ggplot(aes(x = xvar, y = pe), data = preddata) +
    geom_ribbon(aes(ymin = lcl, ymax = ucl), alpha = 0.4, fill = 'navy') +
    geom_line(colour = 'navy') +
    ylab(ystring) +
    theme_bw()

  if(!is.null(intvar)){
    zinf.plot <- zinf.plot +
      facet_wrap(~ intvar.f, nrow = 1) +
      xlab(paste0(xstring, '\n\nP for biomarker, final model: ',
                  formatp(val = zinfobj$p.marker),
                  '\nP for all interactions: ',
                  formatp(val = zinfobj$p.int),
                  '\nP for ', intvar.str, ' interaction: ',
                  formatp(val = unlist(zinfobj[intvar.p])))) +
      theme(strip.text = element_text(face = 'bold'))
  } else{
    zinf.plot <- zinf.plot +
      xlab(paste0(xstring, '\n\nP for biomarker, final model: ',
                  formatp(val = zinfobj$p.marker),
                  '\nP for all interactions: ',
                  formatp(val = zinfobj$p.int)))
  }

  zinf.plot
}

## -- Function to create either one or two plots depending on interaction p-value ------------------
zinf.figures <- function(zinfobj, zinf.preddata, xvar, xstring, ystring){
  if(zinfobj$p.int > 0.20){
    return(list('fig' = list('fig' = plot.zinf.results(zinfobj = zinfobj,
                                                       preddata = zinf.preddata[[1]][[1]],
                                                       xvar = xvar,
                                                       xstring = xstring,
                                                       ystring = ystring)),
                'height' =  4,
                'layoutmat' = matrix(1, ncol = 1)))
  } else{
    fig1 <- plot.zinf.results(zinfobj = zinfobj,
                              preddata = zinf.preddata[[1]][[1]],
                              xvar = xvar, xstring = xstring, ystring = ystring,
                              intvar = 'age.div10',
                              intvar.str = 'Age / 10',
                              intvar.p = 'p.int.age')
    fig2 <- plot.zinf.results(zinfobj = zinfobj,
                              preddata = zinf.preddata[[1]][[2]],
                              xvar = xvar, xstring = xstring, ystring = ystring,
                              intvar = 'il6.log10',
                              intvar.str = 'Log10(IL-6)',
                              intvar.p = 'p.int.il6')

    return(list('fig' = list(fig1, fig2),
                'height' = 8,
                'layoutmat' = matrix(1:2, ncol = 1)))
  }
}




@

\section{Endothelial/BBB Injury Markers vs. Delirium Duration}

To examine the association between endothelial/BBB injury at study enrollment and delirium duration
in the 30 days following, we used negative binomial regression, adjusting for the following
covariates:
\begin{itemize}
\item Charlson score
\item IQCODE score
\item Framingham stroke risk score
\item APACHE acute physiology component
\item Cardiovascular SOFA, study day 1
\item Severe sepsis, study day 1
\end{itemize}

(We considered both linear and proportional odds logistic regression, but assumptions for neither
model type were met adequately.)

We allowed all continuous variables to have a nonlinear association with delirium duration using
restricted cubic splines, with the exceptions of IQCODE and cardiovascular SOFA score, which had
too little variability to make this sensible. We allowed for potential interactions between
endothelial/BBB markers and both systemic inflammation (log10(IL-6)) on study day 1 and age at
study enrollment. If either the global p-value for nonlinearity and/or the global p-value for
interactions were clearly nonsignificant (p $>$ \Sexpr{format(pcutoff, nsmall = 2)}), those terms
are removed from the final model for parsimony. All biomarkers are transformed using the log10
transformation in order to improve model fit and reduce the influence of extremely high values. All
p-values are calculated using the \Sexpr{use.method} method.

% We used multiple imputation to reduce bias from missing covariates.

For models where interaction terms are kept in the final model, the association of the biomarker is
shown for the 25th, 50th, 75th, and 90th percentiles of the interacting variable.

%' <<trymodeltypes>>=
%' ## -- Functions to print model diagnostics ------------------------------------------------------
%' ols.diagnostics <- function(model.obj.ma, labeltext){
%'   par(mfrow = c(1, 2), cex = 0.8, cex.main = 0.9)
%'   plot(resid(model.obj.ma) ~ fitted(model.obj.ma),
%'        xlab = 'Predicted Delirium Days',
%'        ylab = paste('Model residual'),
%'        main = paste('RP plot,', labeltext),
%'        col = 'turquoise4')
%'   abline(h = 0)
%'   qqnorm(resid(model.obj.ma),
%'          datax = TRUE,
%'          main = paste('Q-Q of residuals,', labeltext))
%' }
%'
%' po.assume <- function(model.obj, cuts, model.data){
%'   ## Create data set for each coefficient in main model
%'   cof.names <- names(coef(model.obj))
%'   all.rows <- 1:length(cof.names)
%'   int.rows <- grep('y>=', cof.names, fixed = TRUE)
%'   take.rows <- all.rows[all.rows %nin% int.rows]
%'   cof <- data.frame(var = cof.names[take.rows])
%'
%'   ## Extract formula from model call
%'   comp.call <- as.character(formula(model.obj))
%'   model.outcome <- comp.call[2]
%'   model.formula <- comp.call[3]
%'
%'   for(k in 1:length(cuts)){
%'     cut.mod <- lrm(as.formula(paste('as.numeric(', model.outcome, ' >= ', cuts[k], ') ~ ', model.formula, sep = '')),
%'                    data = model.data)
%'
%'     cof.temp <- data.frame(var = names(coef(cut.mod)),
%'                            hold.place = coef(cut.mod))
%'
%'     cof <- merge(cof, cof.temp, all.x = TRUE, all.y = FALSE)
%'     names(cof) <- gsub('hold.place', paste('coef.cut', cuts[k], sep = '.'), names(cof))
%'   }
%'
%'   ## Subset in case some splines didn't make requested number of knots
%'   cof <- cof[rowSums(is.na(cof[,2:ncol(cof)])) == 0,]
%'   ## Get number of rows/columns for plot (plot as close to square as possible)
%'   plot.rows <- ceil(sqrt(nrow(cof)))
%'
%'   par(mfrow = c(plot.rows, plot.rows), mar = c(2, 4, 1, 1))
%'   for(k in 1:nrow(cof)){
%'     plot(cuts, cof[k, 2:ncol(cof)], type = 'l', ylab = '')
%'     title(ylab = cof[k, 'var'], line = 2.5)
%'     abline(h = 0, lty = 2)
%'   }
%' }
%'
%' ## -- Test linear, POLR regression first to make sure negative binomial is best choice -------------
%' del.lin.bdnf <- ols(del.s.imp ~ rcs(charlson.score, 3) + rcs(iqcode.score.e, 3) +
%'                       rcs(stroke.risk, 3) + rcs(apache.aps, 3) + rcs(cvsofa.day1, 3) +
%'                       sevsepsis.day1 + rcs(age.enroll, 3) * rcs(bdnf.log10, 3) +
%'                       rcs(il6.log10, 3) * rcs(bdnf.log10, 3),
%'                     data = endo.data)
%'
%' del.polr.bdnf <- lrm(del.s.imp ~ rcs(charlson.score, 3) + rcs(iqcode.score.e, 3) +
%'                       rcs(stroke.risk, 3) + rcs(apache.aps, 3) + rcs(cvsofa.day1, 3) +
%'                       sevsepsis.day1 + rcs(age.enroll, 3) * rcs(bdnf.log10, 3) +
%'                       rcs(il6.log10, 3) * rcs(bdnf.log10, 3),
%'                     data = endo.data)
%'
%' ols.diagnostics(del.lin.bdnf, 'BDNF vs Delirium Duration')
%' po.assume(del.polr.bdnf, cuts = seq(1, 10, 1), endo.data)
%'
%' @

<<delmodels>>=
## -- Fit delirium models --------------------------------------------------------------------------
## Formula for full delirium model, subbing "markervar" in place of actual biomarker variable
del.full.formula <- "del.s.imp ~ rcs(charlson.score, 3) + iqcode.score.e + rcs(stroke.risk, 3) + rcs(apache.aps, 3) + cvsofa.day1 + sevsepsis.day1 + rcs(age.div10, 3) + rcs(il6.log10, 3) + rcs(markervar, 3) + rcs(age.div10, 3):rcs(markervar, 3) + rcs(il6.log10, 3):rcs(markervar, 3)"

fit.del.models <- function(marker){
  fit.reg.models(use.marker = marker,
                 formula.full = del.full.formula,
                 modtype = 'nb',
                 dataset = endo.data)
}
bdnf.del <- fit.del.models('bdnf.log10')
esel.del <- fit.del.models('esel.log10')
pai1.del <- fit.del.models('pai1.log10')
s100b.del <- fit.del.models('s100b.log10')
uchl.del <- fit.del.models('uchl.log10')

# ## Test by hand with S100B
# s100b.full.formula <- "del.s.imp ~ rcs(charlson.score, 3) + iqcode.score.e + rcs(stroke.risk, 3) + rcs(apache.aps, 3) + rcs(cvsofa.day1, 3) + sevsepsis.day1 + rcs(age.enroll, 3) + rcs(il6.log10, 3) + rcs(s100b.log10, 3) + rcs(age.enroll, 3):rcs(s100b.log10, 3) + rcs(il6.log10, 3):rcs(s100b.log10, 3)"
# del.s100b.full <- glm.nb(formula = as.formula(s100b.full.formula), data = endo.data)
# 
# ## Test nonlinear terms
# s100b.lin.formula <- "del.s.imp ~ charlson.score + iqcode.score.e + stroke.risk + apache.aps + cvsofa.day1 + sevsepsis.day1 + age.enroll + il6.log10 + s100b.log10 + age.enroll:s100b.log10 + il6.log10:s100b.log10"
# del.s100b.lin <- glm.nb(formula = as.formula(s100b.lin.formula), data = endo.data)
# lmtest::lrtest(del.s100b.full, del.s100b.lin)
# s100b.del$p.nonlin
# 
# ## Nonlinear terms not necessary; test interaction terms
# s100b.noint.formula <- "del.s.imp ~ charlson.score + iqcode.score.e + stroke.risk + apache.aps + cvsofa.day1 + sevsepsis.day1 + age.enroll + il6.log10 + s100b.log10"
# del.s100b.noint <- glm.nb(formula = as.formula(s100b.noint.formula), data = endo.data)
# lmtest::lrtest(del.s100b.lin, del.s100b.noint)
# s100b.del$p.int
# 
# ## Interaction nonsignificant; test overall p-value for S100B
# nomark.formula <- "del.s.imp ~ charlson.score + iqcode.score.e + stroke.risk + apache.aps + cvsofa.day1 + sevsepsis.day1 + age.enroll + il6.log10"
# del.nomark <- glm.nb(formula = as.formula(nomark.formula), data = endo.data)
# lmtest::lrtest(del.s100b.noint, del.nomark)
# s100b.del$p.marker

## -- Create graphics for delirium models ----------------------------------------------------------
nb.figures <- function(nbobj, xvar, xstring, ystring){
  if(nbobj$p.int > 0.20){
    return(list('fig' = list(plot.nb.results(nbobj = nbobj,
                                             xvar = xvar,
                                             xstring = xstring,
                                             ystring = ystring)),
                'height' =  3.75,
                'layoutmat' = matrix(1, ncol = 1)))
  } else{
    fig1 <- plot.nb.results(nbobj = nbobj, xvar = xvar,
                            intvar = 'age.div10', intvals = intvals.age / 10,
                            intstring = 'Age / 10', intp = nbobj$p.int.age,
                            xstring = xstring, ystring = ystring)
    fig2 <- plot.nb.results(nbobj = nbobj, xvar = xvar,
                            intvar = 'il6.log10', intvals = intvals.il6,
                            intstring = 'Log10(IL-6)', intp = nbobj$p.int.il6,
                            xstring = xstring, ystring = ystring)

    return(list('fig' = list(fig1, fig2),
                'height' = 8,
                'layoutmat' = matrix(1:2, ncol = 1)))
  }
}

nb.figures.del <- function(nbobj, xvar, xstring){
  nb.figures(nbobj = nbobj, xvar = xvar, xstring = xstring, ystring = 'Days of Delirium')
}
bdnf.del.fig <- nb.figures.del(nbobj = bdnf.del, xvar = 'bdnf.log10', xstring = 'BDNF')
esel.del.fig <- nb.figures.del(nbobj = esel.del, xvar = 'esel.log10', xstring = 'E-Selectin')
pai1.del.fig <- nb.figures.del(nbobj = pai1.del, xvar = 'pai1.log10', xstring = 'PAI-1')
s100b.del.fig <- nb.figures.del(nbobj = s100b.del, xvar = 's100b.log10', xstring = 'S100B')
uchl.del.fig <- nb.figures.del(nbobj = uchl.del, xvar = 'uchl.log10', xstring = 'UCHL')

pdf(file = 'bdnf_del_results.pdf', width = 8, height = bdnf.del.fig$height)
multiplot(plotlist = bdnf.del.fig$fig, layout = bdnf.del.fig$layoutmat)
dev.off()

pdf(file = 'esel_del_results.pdf', width = 8, height = esel.del.fig$height)
multiplot(plotlist = esel.del.fig$fig, layout = esel.del.fig$layoutmat)
dev.off()

pdf(file = 'pai1_del_results.pdf', width = 8, height = pai1.del.fig$height)
multiplot(plotlist = pai1.del.fig$fig, layout = pai1.del.fig$layoutmat)
dev.off()

pdf(file = 's100b_del_results.pdf', width = 8, height = s100b.del.fig$height)
multiplot(plotlist = s100b.del.fig$fig, layout = s100b.del.fig$layoutmat)
dev.off()

pdf(file = 'uchl_del_results.pdf', width = 8, height = uchl.del.fig$height)
multiplot(plotlist = uchl.del.fig$fig, layout = uchl.del.fig$layoutmat)
dev.off()

@

\subsection{BDNF vs. Days of Delirium}
We see no association between log10(BDNF) at baseline and with delirium duration while in the
hospital.

\begin{figure}[!h]
{\centering\includegraphics{bdnf_del_results.pdf}}
\caption{Log10(BDNF) vs. Delirium Duration}\label{fig:bdnfdel}
\end{figure}

\clearpage
\subsection{E-Selectin vs. Days of Delirium}
We see no association between log(E-selectin) at baseline and with delirium duration while in the
hospital.

\begin{figure}[!h]
{\centering\includegraphics{esel_del_results.pdf}}
\caption{Log10(E-Selectin) vs. Delirium Duration}\label{fig:eseldel}
\end{figure}

% \clearpage
\subsection{PAI-1 vs. Days of Delirium}
We see no association between log(PAI-1) at baseline and with delirium duration while in the
hospital.

\begin{figure}[!h]
{\centering\includegraphics{pai1_del_results.pdf}}
\caption{Log10(PAI-1) vs. Delirium Duration}\label{fig:pai1del}
\end{figure}

\clearpage
\subsection{S100B vs. Days of Delirium}
We see no association between log(S100B) at baseline and with delirium duration while in the
hospital.

\begin{figure}[!h]
{\centering\includegraphics{s100b_del_results.pdf}}
\caption{Log10(S100B) vs. Delirium Duration}\label{fig:s100bdel}
\end{figure}

% \clearpage
\subsection{UCHL vs. Days of Delirium}
UCHL at baseline does show a significant association with days of delirium. This association is not
significantly nonlinear, so we can say that higher log10(UCHL) at study enrollment is significantly
associated with fewer days of delirium. This association is not modified by age or systemic
inflammation (IL-6).

\begin{figure}[!h]
{\centering\includegraphics{uchl_del_results.pdf}}
\caption{Log10(UCHL) vs. Delirium Duration}\label{fig:uchldel}
\end{figure}




\clearpage
\section{Endothelial/BBB Injury Markers vs. Katz ADL}

To examine the association between endothelial/BBB injury at study enrollment and Katz ADL scores
at 3- and 12-month followup, we used zero-inflated negative binomial regression, adjusting for the
following covariates on the count side of the model:
\begin{itemize}
\item Charlson score
\item Years of education
\item Katz ADL at enrollment
% \item FAQ at enrollment
\item IQCODE score
\item Framingham stroke risk score
\item Mean daily modified SOFA (no GCS) during ICU stay
\item Duration of severe sepsis
\item Duration of delirium
\item Duration of coma
\end{itemize}

On the zero-inflation side of the model, we included age / 10, Charlson score, ADL at enrollment,
and mean modified SOFA in the ICU. Age was divided by ten in order to make the coefficient easier
to distinguish from zero; this was proving to be a computational issue in models using the original
scale.

(Based on previous analyses, we do not believe assumptions for either linear or proportional odds
logistic regression would be met adequately. We also looked at negative binomial regression, but
inconsistent results and the Vuong test both indicated that zero-inflated models are better fits
for this outcome.)

In order to make sure models were stable, all continuous variables were forced to have a linear relationship with Katz ADL scores, including biomarker terms. We allowed for potential interactions
between endothelial/BBB markers and both systemic inflammation (log10(IL-6)) on study day 1 and age
at study enrollment. If the global p-value for interactions were clearly nonsignificant (p $>$
\Sexpr{format(pcutoff, nsmall = 2)}), those terms are removed from the final model for parsimony.
All biomarkers are transformed using the log10 transformation in order to improve model fit and
reduce the influence of extremely high values. All p-values are calculated using the
\Sexpr{use.method} method. Confidence limits for predicted values are calculated using the
bootstrap: we ran the final model for each biomarker on \Sexpr{n.bootsets} bootstrapped data sets, calculated the predicted values of ADL score at each unique value of the biomarker for each model fit, and took the 2.5th and 97.5th percentiles of those predicted values as the confidence limits.

% We used multiple imputation to reduce bias from missing covariates.

For models where interaction terms are kept in the final model, the association of the biomarker is
shown for the 25th, 50th, 75th, and 90th percentiles of the interacting variable.

%' <<adlmodels>>=
%' # ## Formulas for full ADL models, subbing "markervar" in place of actual biomarker variable
%' # adl.righthand <- "rcs(charlson.score, 3) + rcs(edu, 3) + iqcode.score.e + rcs(stroke.risk, 3) + adl.e + rcs(mean.modsofa.icu, 3) + rcs(icudays.sevseptic.s, 3) + rcs(del.s.imp, 3) + rcs(coma.s.imp, 3) + rcs(age.div10, 3) + rcs(il6.log10, 3) + rcs(markervar, 3) + rcs(age.div10, 3):rcs(markervar, 3) + rcs(il6.log10, 3):rcs(markervar, 3) | rcs(age.div10, 3) + rcs(charlson.score, 3) + adl.e + rcs(mean.modsofa.icu, 3)"
%' #
%' # adl.full.formula.3 <- paste("adl.totscore.3 ~", adl.righthand)
%' # adl.full.formula.12 <- paste("adl.totscore.12 ~", adl.righthand)
%' 
%' ## Have to force all terms to be linear due to model instability
%' ## Formulas for full ADL models, subbing "markervar" in place of actual biomarker variable
%' adl.righthand.lin <- "charlson.score + edu + iqcode.score.e + stroke.risk + adl.e + mean.modsofa.icu + icudays.sevseptic.s + del.s.imp + coma.s.imp + age.div10 + il6.log10 + markervar + age.div10:markervar + il6.log10:markervar | age.div10 + charlson.score + adl.e + mean.modsofa.icu"
%' 
%' adl.lin.formula.3 <- paste("adl.totscore.3 ~", adl.righthand.lin)
%' adl.lin.formula.12 <- paste("adl.totscore.12 ~", adl.righthand.lin)
%' 
%' ## -- Fit 3-month ADL models -----------------------------------------------------------------------
%' fit.adl.models.3 <- function(marker){
%'   fit.reg.models(use.marker = marker,
%'                  formula.full = adl.lin.formula.3,
%'                  modtype = 'zeroinfl',
%'                  dataset = endo.data)
%' }
%' bdnf.adl.3 <- fit.adl.models.3('bdnf.log10')
%' esel.adl.3 <- fit.adl.models.3('esel.log10')
%' pai1.adl.3 <- fit.adl.models.3('pai1.log10')
%' s100b.adl.3 <- fit.adl.models.3('s100b.log10')
%' uchl.adl.3 <- fit.adl.models.3('uchl.log10')
%' 
%' # ## Test PAI-1 by hand to make sure
%' # endo.data.adl.pai1.3 <-
%' #   endo.data[rowSums(is.na(endo.data[,c('adl.totscore.3', 'charlson.score', 'edu', 'iqcode.score.e',
%' #                                        'stroke.risk', 'mean.modsofa.icu', 'icudays.sevseptic.s',
%' #                                        'del.s.imp', 'coma.s.imp', 'age.div10', 'il6.log10',
%' #                                        'pai1.log10')])) == 0,]
%' # pai1.org <- zeroinfl(adl.totscore.3 ~ charlson.score + edu + iqcode.score.e + stroke.risk + adl.e +
%' #                         mean.modsofa.icu + icudays.sevseptic.s + del.s.imp + coma.s.imp +
%' #                         age.div10 + il6.log10 + pai1.log10 + age.div10:pai1.log10 +
%' #                         il6.log10:pai1.log10 |
%' #                        age.div10 + charlson.score + adl.e + mean.modsofa.icu,
%' #                      dist = 'negbin',
%' #                      data = endo.data.adl.pai1.3)
%' #
%' # ## Test for interactions
%' # pai1.noint <- zeroinfl(adl.totscore.3 ~ charlson.score + edu + iqcode.score.e + stroke.risk +
%' #                           adl.e + mean.modsofa.icu + icudays.sevseptic.s + del.s.imp + coma.s.imp +
%' #                           age.div10 + il6.log10 + pai1.log10 |
%' #                          age.div10 + charlson.score + adl.e + mean.modsofa.icu,
%' #                        dist = 'negbin',
%' #                        data = endo.data.adl.pai1.3)
%' # lmtest::lrtest(pai1.org, pai1.noint)
%' # pai1.adl.3$p.int
%' #
%' # ## Interaction terms needed; test for age and IL-6 separately
%' # pai1.noage <- zeroinfl(adl.totscore.3 ~ charlson.score + edu + iqcode.score.e + stroke.risk +
%' #                           adl.e + mean.modsofa.icu + icudays.sevseptic.s + del.s.imp + coma.s.imp +
%' #                           age.div10 + il6.log10 + pai1.log10 + il6.log10:pai1.log10 |
%' #                          age.div10 + charlson.score + adl.e + mean.modsofa.icu,
%' #                        dist = 'negbin',
%' #                        data = endo.data.adl.pai1.3)
%' # lmtest::lrtest(pai1.org, pai1.noage)
%' # pai1.adl.3$p.int.age
%' #
%' # pai1.noil6 <- zeroinfl(adl.totscore.3 ~ charlson.score + edu + iqcode.score.e + stroke.risk +
%' #                          adl.e + mean.modsofa.icu + icudays.sevseptic.s + del.s.imp + coma.s.imp +
%' #                          age.div10 + il6.log10 + pai1.log10 + age.div10:pai1.log10 |
%' #                         age.div10 + charlson.score + adl.e + mean.modsofa.icu,
%' #                        dist = 'negbin',
%' #                        data = endo.data.adl.pai1.3)
%' # lmtest::lrtest(pai1.org, pai1.noil6)
%' # pai1.adl.3$p.int.il6
%' 
%' # ## Test for biomarker
%' # pai1.nomark <- zeroinfl(adl.totscore.3 ~ charlson.score + edu + iqcode.score.e + stroke.risk +
%' #                            adl.e + mean.modsofa.icu + icudays.sevseptic.s + del.s.imp + coma.s.imp +
%' #                            age.div10 + il6.log10 |
%' #                           age.div10 + charlson.score + adl.e + mean.modsofa.icu,
%' #                         dist = 'negbin',
%' #                         data = endo.data.adl.pai1.3)
%' # lmtest::lrtest(pai1.noint, pai1.nomark)
%' # pai1.adl.3$p.marker
%' 
%' 
%' ## -- Fit 12-month ADL models ----------------------------------------------------------------------
%' fit.adl.models.12 <- function(marker){
%'   fit.reg.models(use.marker = marker,
%'                  formula.full = adl.lin.formula.12,
%'                  modtype = 'zeroinfl',
%'                  dataset = endo.data)
%' }
%' bdnf.adl.12 <- fit.adl.models.12('bdnf.log10')
%' esel.adl.12 <- fit.adl.models.12('esel.log10')
%' pai1.adl.12 <- fit.adl.models.12('pai1.log10')
%' s100b.adl.12 <- fit.adl.models.12('s100b.log10')
%' uchl.adl.12 <- fit.adl.models.12('uchl.log10')
%' 
%' ## -- Create data frame of point estimates, CIs for unique values of biomarker ---------------------
%' ## --  (+ interacting variable, if needed) ---------------------------------------------------------
%' 
%' # ## Create bootstrapped data sets, save in .Rdata file to save time
%' # disability.covars <- c('charlson.score', 'edu', 'iqcode.score.e', 'stroke.risk', 'adl.e',
%' #                        'mean.modsofa.icu', 'icudays.sevseptic.s', 'del.s.imp', 'coma.s.imp',
%' #                        'age.div10', 'il6.log10')
%' # 
%' # nboot <- 1000
%' # 
%' # ## Function to create bootstrapped data sets
%' # disability.bootdata <- function(use.marker, outcome){
%' #   nomiss.vars <- c(disability.covars, use.marker, outcome)
%' #   create.sampdata(org.data = endo.data[rowSums(is.na(endo.data[,nomiss.vars])) == 0,
%' #                                        c('id', nomiss.vars)],
%' #                   id.var = 'id',
%' #                   n.sets = nboot)
%' # }
%' # 
%' # bdnf.adl.3.bootdata <- disability.bootdata('bdnf.log10', 'adl.totscore.3')
%' # esel.adl.3.bootdata <- disability.bootdata('esel.log10', 'adl.totscore.3')
%' # pai1.adl.3.bootdata <- disability.bootdata('pai1.log10', 'adl.totscore.3')
%' # s100b.adl.3.bootdata <- disability.bootdata('s100b.log10', 'adl.totscore.3')
%' # uchl.adl.3.bootdata <- disability.bootdata('uchl.log10', 'adl.totscore.3')
%' # 
%' # bdnf.adl.12.bootdata <- disability.bootdata('bdnf.log10', 'adl.totscore.12')
%' # esel.adl.12.bootdata <- disability.bootdata('esel.log10', 'adl.totscore.12')
%' # pai1.adl.12.bootdata <- disability.bootdata('pai1.log10', 'adl.totscore.12')
%' # s100b.adl.12.bootdata <- disability.bootdata('s100b.log10', 'adl.totscore.12')
%' # uchl.adl.12.bootdata <- disability.bootdata('uchl.log10', 'adl.totscore.12')
%' # 
%' # save(bdnf.adl.3.bootdata, esel.adl.3.bootdata, pai1.adl.3.bootdata, s100b.adl.3.bootdata,
%' #      uchl.adl.3.bootdata, bdnf.adl.12.bootdata, esel.adl.12.bootdata, pai1.adl.12.bootdata,
%' #      s100b.adl.12.bootdata, uchl.adl.12.bootdata,
%' #      file = 'adl_bootdata.Rdata')
%' 
%' load('adl_bootdata.Rdata')
%' 
%' bdnf.adl.3.preddata <- zinf.plotdata(modobj = bdnf.adl.3$final.mod,
%'                                      xvar = 'bdnf.log10',
%'                                      bootdata = bdnf.adl.3.bootdata)
%' bdnf.adl.12.preddata <- zinf.plotdata(modobj = bdnf.adl.12$final.mod,
%'                                       xvar = 'bdnf.log10',
%'                                       bootdata = bdnf.adl.12.bootdata)
%' 
%' esel.adl.3.preddata <- zinf.plotdata(modobj = esel.adl.3$final.mod,
%'                                      xvar = 'esel.log10',
%'                                      bootdata = esel.adl.3.bootdata)
%' esel.adl.12.preddata <- zinf.plotdata(modobj = esel.adl.12$final.mod,
%'                                       xvar = 'esel.log10',
%'                                       bootdata = esel.adl.12.bootdata)
%' 
%' pai1.adl.3.preddata <- zinf.plotdata(modobj = pai1.adl.3$final.mod,
%'                                      xvar = 'pai1.log10',
%'                                      bootdata = pai1.adl.3.bootdata)
%' pai1.adl.12.preddata <- zinf.plotdata(modobj = pai1.adl.12$final.mod,
%'                                       xvar = 'pai1.log10',
%'                                       bootdata = pai1.adl.12.bootdata)
%' 
%' s100b.adl.3.preddata <- zinf.plotdata(modobj = s100b.adl.3$final.mod,
%'                                       xvar = 's100b.log10',
%'                                       bootdata = s100b.adl.3.bootdata)
%' s100b.adl.12.preddata <- zinf.plotdata(modobj = s100b.adl.12$final.mod,
%'                                        xvar = 's100b.log10',
%'                                        bootdata = s100b.adl.12.bootdata)
%' 
%' uchl.adl.3.preddata <- zinf.plotdata(modobj = uchl.adl.3$final.mod,
%'                                      xvar = 'uchl.log10',
%'                                      bootdata = uchl.adl.3.bootdata)
%' uchl.adl.12.preddata <- zinf.plotdata(modobj = uchl.adl.12$final.mod,
%'                                       xvar = 'uchl.log10',
%'                                       bootdata = uchl.adl.12.bootdata)
%' 
%' ## -- Plot ADL results -----------------------------------------------------------------------------
%' ## 3 months
%' bdnf.adl.3.fig <-
%'   zinf.figures(zinfobj = bdnf.adl.3, zinf.preddata = bdnf.adl.3.preddata,
%'                xvar = 'bdnf.log10', xstring = 'Log10(BDNF)',
%'                ystring = 'Adjusted Katz ADL, 3 Months')
%' esel.adl.3.fig <-
%'   zinf.figures(zinfobj = esel.adl.3, zinf.preddata = esel.adl.3.preddata,
%'                xvar = 'esel.log10', xstring = 'Log10(E-selectin)',
%'                ystring = 'Adjusted Katz ADL, 3 Months')
%' pai1.adl.3.fig <-
%'   zinf.figures(zinfobj = pai1.adl.3, zinf.preddata = pai1.adl.3.preddata,
%'                xvar = 'pai1.log10', xstring = 'Log10(PAI-1)',
%'                ystring = 'Adjusted Katz ADL, 3 Months')
%' s100b.adl.3.fig <-
%'   zinf.figures(zinfobj = s100b.adl.3, zinf.preddata = s100b.adl.3.preddata,
%'                xvar = 's100b.log10', xstring = 'Log10(S100B)',
%'                ystring = 'Adjusted Katz ADL, 3 Months')
%' uchl.adl.3.fig <-
%'   zinf.figures(zinfobj = uchl.adl.3, zinf.preddata = uchl.adl.3.preddata,
%'                xvar = 'uchl.log10', xstring = 'Log10(UCHL)',
%'                ystring = 'Adjusted Katz ADL, 3 Months')
%' 
%' pdf(file = 'bdnf_adl3_results.pdf', width = 8, height = bdnf.adl.3.fig$height)
%' multiplot(plotlist = bdnf.adl.3.fig$fig, layout = bdnf.adl.3.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'esel_adl3_results.pdf', width = 8, height = esel.adl.3.fig$height)
%' multiplot(plotlist = esel.adl.3.fig$fig, layout = esel.adl.3.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'pai1_adl3_results.pdf', width = 8, height = pai1.adl.3.fig$height)
%' multiplot(plotlist = pai1.adl.3.fig$fig, layout = pai1.adl.3.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 's100b_adl3_results.pdf', width = 8, height = s100b.adl.3.fig$height)
%' multiplot(plotlist = s100b.adl.3.fig$fig, layout = s100b.adl.3.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'uchl_adl3_results.pdf', width = 8, height = uchl.adl.3.fig$height)
%' multiplot(plotlist = uchl.adl.3.fig$fig, layout = uchl.adl.3.fig$layoutmat)
%' dev.off()
%' 
%' ## 12 months
%' bdnf.adl.12.fig <-
%'   zinf.figures(zinfobj = bdnf.adl.12, zinf.preddata = bdnf.adl.12.preddata,
%'                xvar = 'bdnf.log10', xstring = 'Log10(BDNF)',
%'                ystring = 'Adjusted Katz ADL, 12 Months')
%' esel.adl.12.fig <-
%'   zinf.figures(zinfobj = esel.adl.12, zinf.preddata = esel.adl.12.preddata,
%'                xvar = 'esel.log10', xstring = 'Log10(E-selectin)',
%'                ystring = 'Adjusted Katz ADL, 12 Months')
%' pai1.adl.12.fig <-
%'   zinf.figures(zinfobj = pai1.adl.12, zinf.preddata = pai1.adl.12.preddata,
%'                xvar = 'pai1.log10', xstring = 'Log10(PAI-1)',
%'                ystring = 'Adjusted Katz ADL, 12 Months')
%' s100b.adl.12.fig <-
%'   zinf.figures(zinfobj = s100b.adl.12, zinf.preddata = s100b.adl.12.preddata,
%'                xvar = 's100b.log10', xstring = 'Log10(S100B)',
%'                ystring = 'Adjusted Katz ADL, 12 Months')
%' uchl.adl.12.fig <-
%'   zinf.figures(zinfobj = uchl.adl.12, zinf.preddata = uchl.adl.12.preddata,
%'                xvar = 'uchl.log10', xstring = 'Log10(UCHL)',
%'                ystring = 'Adjusted Katz ADL, 12 Months')
%' 
%' pdf(file = 'bdnf_adl12_results.pdf', width = 8, height = bdnf.adl.12.fig$height)
%' multiplot(bdnf.adl.12.fig$fig, layout = bdnf.adl.12.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'esel_adl12_results.pdf', width = 8, height = esel.adl.12.fig$height)
%' multiplot(esel.adl.12.fig$fig, layout = esel.adl.12.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'pai1_adl12_results.pdf', width = 8, height = pai1.adl.12.fig$height)
%' multiplot(pai1.adl.12.fig$fig, layout = pai1.adl.12.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 's100b_adl12_results.pdf', width = 8, height = s100b.adl.12.fig$height)
%' multiplot(s100b.adl.12.fig$fig, layout = s100b.adl.12.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'uchl_adl12_results.pdf', width = 8, height = uchl.adl.12.fig$height)
%' multiplot(uchl.adl.12.fig$fig, layout = uchl.adl.12.fig$layoutmat)
%' dev.off()
%' 
%' @

\clearpage
\subsection{BDNF vs. Katz ADL}
We see no significant overall association between log10(BDNF) at baseline and Katz ADL scores at
either 3 or 12 months after discharge. A mild interaction between log10(BDNF) and age exists at 3
months, but any association disappears by 12 months.

\begin{figure}[!h]
{\centering\includegraphics{bdnf_adl3_results.pdf}}
\caption{Log10(BDNF) vs. Katz ADL at 3 Months}\label{fig:bdnfadl3}
\end{figure}
\begin{figure}[!h]
{\centering\includegraphics{bdnf_adl12_results.pdf}}
\caption{Log10(BDNF) vs. Katz ADL at 12 Months}\label{fig:bdnfadl12}
\end{figure}

\clearpage
\subsection{E-selectin vs. Katz ADL}
We see no significant overall association between log10(E-selectin) at baseline and Katz ADL scores
at either 3 or 12 months after discharge.

\begin{figure}[!h]
{\centering\includegraphics{esel_adl3_results.pdf}}
\caption{Log10(E-selectin) vs. Katz ADL at 3 Months}\label{fig:eseladl3}
\end{figure}
\begin{figure}[!h]
{\centering\includegraphics{esel_adl12_results.pdf}}
\caption{Log10(E-selectin) vs. Katz ADL at 12 Months}\label{fig:eseladl12}
\end{figure}

\clearpage
\subsection{PAI-1 vs. Katz ADL}
We see no significant overall association between log10(PAI-1) at baseline and Katz ADL scores at
either 3 or 12 months after discharge. There is an interaction between log10(PAI-1) and log10(IL-6)
at 3 months, but this interaction is not present at 12 months, and is not strong enough at either
time point to result in a significant overall association between log10(PAI-1) and ADL scores.

\begin{figure}[!h]
{\centering\includegraphics{pai1_adl3_results.pdf}}
\caption{Log10(PAI-1) vs. Katz ADL at 3 Months}\label{fig:pai1adl3}
\end{figure}
\begin{figure}[!h]
{\centering\includegraphics{pai1_adl12_results.pdf}}
\caption{Log10(PAI-1) vs. Katz ADL at 12 Months}\label{fig:pai1adl12}
\end{figure}

\clearpage
\subsection{S100B vs. Katz ADL}
We see no significant overall association between log10(S100B) at baseline and Katz ADL scores at
either 3 or 12 months after discharge.

\begin{figure}[!h]
{\centering\includegraphics{s100b_adl3_results.pdf}}
\caption{Log10(S100B) vs. Katz ADL at 3 Months}\label{fig:s100badl3}
\end{figure}
\begin{figure}[!h]
{\centering\includegraphics{s100b_adl12_results.pdf}}
\caption{Log10(S100B) vs. Katz ADL at 12 Months}\label{fig:s100badl12}
\end{figure}

\clearpage
\subsection{UCHL vs. Katz ADL}
We see no significant overall association between log10(UCHL) at baseline and Katz ADL scores at
either 3 or 12 months after discharge.

\begin{figure}[!h]
{\centering\includegraphics{uchl_adl3_results.pdf}}
\caption{Log10(UCHL) vs. Katz ADL at 3 Months}\label{fig:uchladl3}
\end{figure}
\begin{figure}[!h]
{\centering\includegraphics{bdnf_adl12_results.pdf}}
\caption{Log10(UCHL) vs. Katz ADL at 12 Months}\label{fig:uchladl12}
\end{figure}


\section{Endothelial/BBB Injury Markers vs. Functional Activities Questionnaire}

To examine the association between endothelial/BBB injury at study enrollment and FAQ scores
at 3- and 12-month followup, we used zero-inflated negative binomial regression, adjusting for the
following covariates on the count side of the model:
\begin{itemize}
\item Charlson score
\item Years of education
\item Katz ADL at enrollment
% \item FAQ at enrollment
\item IQCODE score
\item Framingham stroke risk score
\item Mean daily modified SOFA (no GCS) during ICU stay
\item Duration of severe sepsis
\item Duration of delirium
\item Duration of coma
\end{itemize}

On the zero-inflation side of the model, we included age / 10, Charlson score, ADL at enrollment,
and mean modified SOFA in the ICU. Age was divided by ten in order to make the coefficient easier
to distinguish from zero; this was proving to be a computational issue in models using the original
scale.

(Based on previous analyses, we do not believe assumptions for either linear or proportional odds
logistic regression would be met adequately. We also looked at negative binomial regression, but
inconsistent results and the Vuong test both indicated that zero-inflated models are better fits
for this outcome.)

In order to make sure models were stable, all continuous variables were forced to have a linear relationship with FAQ scores, including biomarker terms. We allowed for potential interactions
between endothelial/BBB markers and both systemic inflammation (log10(IL-6)) on study day 1 and age
at study enrollment. If the global p-value for interactions were clearly nonsignificant (p $>$
\Sexpr{format(pcutoff, nsmall = 2)}), those terms are removed from the final model for parsimony.
All biomarkers are transformed using the log10 transformation in order to improve model fit and
reduce the influence of extremely high values. All p-values are calculated using the
\Sexpr{use.method} method. Confidence limits for predicted values are calculated using the
bootstrap: we ran the final model for each biomarker on \Sexpr{n.bootsets} bootstrapped data sets,
calculated the predicted values of ADL score at each unique value of the biomarker for each model
fit, and took the 2.5th and 97.5th percentiles of those predicted values as the confidence
limits.

% We used multiple imputation to reduce bias from missing covariates.

For models where interaction terms are kept in the final model, the association of the biomarker is
shown for the 25th, 50th, 75th, and 90th percentiles of the interacting variable.

%' <<faqmodels>>=
%' ## Have to force all terms to be linear due to model instability
%' ## Formulas for full ADL models, subbing "markervar" in place of actual biomarker variable
%' faq.righthand.lin <- "charlson.score + edu + iqcode.score.e + stroke.risk + adl.e + mean.modsofa.icu + icudays.sevseptic.s + del.s.imp + coma.s.imp + age.div10 + il6.log10 + markervar + age.div10:markervar + il6.log10:markervar | age.div10 + charlson.score + adl.e + mean.modsofa.icu"
%' 
%' faq.lin.formula.3 <- paste("faq.rdscore.3 ~", faq.righthand.lin)
%' faq.lin.formula.12 <- paste("faq.rdscore.12 ~", faq.righthand.lin)
%' 
%' ## -- Fit 3-month FAQ models -----------------------------------------------------------------------
%' fit.faq.models.3 <- function(marker){
%'   fit.reg.models(use.marker = marker,
%'                  formula.full = faq.lin.formula.3,
%'                  modtype = 'zeroinfl',
%'                  dataset = endo.data)
%' }
%' bdnf.faq.3 <- fit.faq.models.3('bdnf.log10')
%' esel.faq.3 <- fit.faq.models.3('esel.log10')
%' pai1.faq.3 <- fit.faq.models.3('pai1.log10')
%' s100b.faq.3 <- fit.faq.models.3('s100b.log10')
%' uchl.faq.3 <- fit.faq.models.3('uchl.log10')
%' 
%' ## -- Fit 12-month FAQ models ----------------------------------------------------------------------
%' fit.faq.models.12 <- function(marker){
%'   fit.reg.models(use.marker = marker,
%'                  formula.full = faq.lin.formula.12,
%'                  modtype = 'zeroinfl',
%'                  dataset = endo.data)
%' }
%' bdnf.faq.12 <- fit.faq.models.12('bdnf.log10')
%' esel.faq.12 <- fit.faq.models.12('esel.log10')
%' pai1.faq.12 <- fit.faq.models.12('pai1.log10')
%' s100b.faq.12 <- fit.faq.models.12('s100b.log10')
%' uchl.faq.12 <- fit.faq.models.12('uchl.log10')
%' 
%' ## -- Create data frame of point estimates, CIs for unique values of biomarker ---------------------
%' ## --  (+ interacting variable, if needed) ---------------------------------------------------------
%' 
%' # ## Create bootstrapped data sets, save in .Rdata file to save time
%' # disability.covars <- c('charlson.score', 'edu', 'iqcode.score.e', 'stroke.risk', 'adl.e',
%' #                        'mean.modsofa.icu', 'icudays.sevseptic.s', 'del.s.imp', 'coma.s.imp',
%' #                        'age.div10', 'il6.log10')
%' # 
%' # nboot <- 1000
%' # 
%' # ## Function to create bootstrapped data sets
%' # disability.bootdata <- function(use.marker, outcome){
%' #   nomiss.vars <- c(disability.covars, use.marker, outcome)
%' #   create.sampdata(org.data = endo.data[rowSums(is.na(endo.data[,nomiss.vars])) == 0,
%' #                                        c('id', nomiss.vars)],
%' #                   id.var = 'id',
%' #                   n.sets = nboot)
%' # }
%' # 
%' # bdnf.faq.3.bootdata <- disability.bootdata('bdnf.log10', 'faq.rdscore.3')
%' # esel.faq.3.bootdata <- disability.bootdata('esel.log10', 'faq.rdscore.3')
%' # pai1.faq.3.bootdata <- disability.bootdata('pai1.log10', 'faq.rdscore.3')
%' # s100b.faq.3.bootdata <- disability.bootdata('s100b.log10', 'faq.rdscore.3')
%' # uchl.faq.3.bootdata <- disability.bootdata('uchl.log10', 'faq.rdscore.3')
%' # 
%' # bdnf.faq.12.bootdata <- disability.bootdata('bdnf.log10', 'faq.rdscore.12')
%' # esel.faq.12.bootdata <- disability.bootdata('esel.log10', 'faq.rdscore.12')
%' # pai1.faq.12.bootdata <- disability.bootdata('pai1.log10', 'faq.rdscore.12')
%' # s100b.faq.12.bootdata <- disability.bootdata('s100b.log10', 'faq.rdscore.12')
%' # uchl.faq.12.bootdata <- disability.bootdata('uchl.log10', 'faq.rdscore.12')
%' # 
%' # save(bdnf.faq.3.bootdata, esel.faq.3.bootdata, pai1.faq.3.bootdata, s100b.faq.3.bootdata,
%' #      uchl.faq.3.bootdata, bdnf.faq.12.bootdata, esel.faq.12.bootdata, pai1.faq.12.bootdata,
%' #      s100b.faq.12.bootdata, uchl.faq.12.bootdata,
%' #      file = 'faq_bootdata.Rdata')
%' 
%' load('faq_bootdata.Rdata')
%' 
%' bdnf.faq.3.preddata <- zinf.plotdata(modobj = bdnf.faq.3$final.mod,
%'                                      xvar = 'bdnf.log10',
%'                                      bootdata = bdnf.faq.3.bootdata)
%' bdnf.faq.12.preddata <- zinf.plotdata(modobj = bdnf.faq.12$final.mod,
%'                                       xvar = 'bdnf.log10',
%'                                       bootdata = bdnf.faq.12.bootdata)
%' 
%' esel.faq.3.preddata <- zinf.plotdata(modobj = esel.faq.3$final.mod,
%'                                      xvar = 'esel.log10',
%'                                      bootdata = esel.faq.3.bootdata)
%' esel.faq.12.preddata <- zinf.plotdata(modobj = esel.faq.12$final.mod,
%'                                       xvar = 'esel.log10',
%'                                       bootdata = esel.faq.12.bootdata)
%' 
%' pai1.faq.3.preddata <- zinf.plotdata(modobj = pai1.faq.3$final.mod,
%'                                      xvar = 'pai1.log10',
%'                                      bootdata = pai1.faq.3.bootdata)
%' pai1.faq.12.preddata <- zinf.plotdata(modobj = pai1.faq.12$final.mod,
%'                                       xvar = 'pai1.log10',
%'                                       bootdata = pai1.faq.12.bootdata)
%' 
%' s100b.faq.3.preddata <- zinf.plotdata(modobj = s100b.faq.3$final.mod,
%'                                       xvar = 's100b.log10',
%'                                       bootdata = s100b.faq.3.bootdata)
%' s100b.faq.12.preddata <- zinf.plotdata(modobj = s100b.faq.12$final.mod,
%'                                        xvar = 's100b.log10',
%'                                        bootdata = s100b.faq.12.bootdata)
%' 
%' uchl.faq.3.preddata <- zinf.plotdata(modobj = uchl.faq.3$final.mod,
%'                                      xvar = 'uchl.log10',
%'                                      bootdata = uchl.faq.3.bootdata)
%' uchl.faq.12.preddata <- zinf.plotdata(modobj = uchl.faq.12$final.mod,
%'                                       xvar = 'uchl.log10',
%'                                       bootdata = uchl.faq.12.bootdata)
%' 
%' ## -- Plot FAQ results -----------------------------------------------------------------------------
%' ## 3 months
%' bdnf.faq.3.fig <-
%'   zinf.figures(zinfobj = bdnf.faq.3, zinf.preddata = bdnf.faq.3.preddata,
%'                xvar = 'bdnf.log10', xstring = 'Log10(BDNF)',
%'                ystring = 'Adjusted FAQ, 3 Months')
%' esel.faq.3.fig <-
%'   zinf.figures(zinfobj = esel.faq.3, zinf.preddata = esel.faq.3.preddata,
%'                xvar = 'esel.log10', xstring = 'Log10(E-selectin)',
%'                ystring = 'Adjusted FAQ, 3 Months')
%' pai1.faq.3.fig <-
%'   zinf.figures(zinfobj = pai1.faq.3, zinf.preddata = pai1.faq.3.preddata,
%'                xvar = 'pai1.log10', xstring = 'Log10(PAI-1)',
%'                ystring = 'Adjusted FAQ, 3 Months')
%' s100b.faq.3.fig <-
%'   zinf.figures(zinfobj = s100b.faq.3, zinf.preddata = s100b.faq.3.preddata,
%'                xvar = 's100b.log10', xstring = 'Log10(S100B)',
%'                ystring = 'Adjusted FAQ, 3 Months')
%' uchl.faq.3.fig <-
%'   zinf.figures(zinfobj = uchl.faq.3, zinf.preddata = uchl.faq.3.preddata,
%'                xvar = 'uchl.log10', xstring = 'Log10(UCHL)',
%'                ystring = 'Adjusted FAQ, 3 Months')
%' 
%' pdf(file = 'bdnf_faq3_results.pdf', width = 8, height = bdnf.faq.3.fig$height)
%' multiplot(plotlist = bdnf.faq.3.fig$fig, layout = bdnf.faq.3.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'esel_faq3_results.pdf', width = 8, height = esel.faq.3.fig$height)
%' multiplot(plotlist = esel.faq.3.fig$fig, layout = esel.faq.3.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'pai1_faq3_results.pdf', width = 8, height = pai1.faq.3.fig$height)
%' multiplot(plotlist = pai1.faq.3.fig$fig, layout = pai1.faq.3.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 's100b_faq3_results.pdf', width = 8, height = s100b.faq.3.fig$height)
%' multiplot(plotlist = s100b.faq.3.fig$fig, layout = s100b.faq.3.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'uchl_faq3_results.pdf', width = 8, height = uchl.faq.3.fig$height)
%' multiplot(plotlist = uchl.faq.3.fig$fig, layout = uchl.faq.3.fig$layoutmat)
%' dev.off()
%' 
%' ## 12 months
%' bdnf.faq.12.fig <-
%'   zinf.figures(zinfobj = bdnf.faq.12, zinf.preddata = bdnf.faq.12.preddata,
%'                xvar = 'bdnf.log10', xstring = 'Log10(BDNF)',
%'                ystring = 'Adjusted FAQ, 12 Months')
%' esel.faq.12.fig <-
%'   zinf.figures(zinfobj = esel.faq.12, zinf.preddata = esel.faq.12.preddata,
%'                xvar = 'esel.log10', xstring = 'Log10(E-selectin)',
%'                ystring = 'Adjusted FAQ, 12 Months')
%' pai1.faq.12.fig <-
%'   zinf.figures(zinfobj = pai1.faq.12, zinf.preddata = pai1.faq.12.preddata,
%'                xvar = 'pai1.log10', xstring = 'Log10(PAI-1)',
%'                ystring = 'Adjusted FAQ, 12 Months')
%' s100b.faq.12.fig <-
%'   zinf.figures(zinfobj = s100b.faq.12, zinf.preddata = s100b.faq.12.preddata,
%'                xvar = 's100b.log10', xstring = 'Log10(S100B)',
%'                ystring = 'Adjusted FAQ, 12 Months')
%' uchl.faq.12.fig <-
%'   zinf.figures(zinfobj = uchl.faq.12, zinf.preddata = uchl.faq.12.preddata,
%'                xvar = 'uchl.log10', xstring = 'Log10(UCHL)',
%'                ystring = 'Adjusted FAQ, 12 Months')
%' 
%' pdf(file = 'bdnf_faq12_results.pdf', width = 8, height = bdnf.faq.12.fig$height)
%' multiplot(plotlist = bdnf.faq.12.fig$fig, layout = bdnf.faq.12.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'esel_faq12_results.pdf', width = 8, height = esel.faq.12.fig$height)
%' multiplot(plotlist = esel.faq.12.fig$fig, layout = esel.faq.12.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'pai1_faq12_results.pdf', width = 8, height = pai1.faq.12.fig$height)
%' multiplot(plotlist = pai1.faq.12.fig$fig, layout = pai1.faq.12.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 's100b_faq12_results.pdf', width = 8, height = s100b.faq.12.fig$height)
%' multiplot(plotlist = s100b.faq.12.fig$fig, layout = s100b.faq.12.fig$layoutmat)
%' dev.off()
%' 
%' pdf(file = 'uchl_faq12_results.pdf', width = 8, height = uchl.faq.12.fig$height)
%' multiplot(plotlist = uchl.faq.12.fig$fig, layout = uchl.faq.12.fig$layoutmat)
%' dev.off()
%' 
%' @

\clearpage
\subsection{BDNF vs. FAQ}
We see no significant overall association between log10(BDNF) at baseline and FAQ scores at
either 3 or 12 months after discharge.

\begin{figure}[!h]
{\centering\includegraphics{bdnf_faq3_results.pdf}}
\caption{Log10(BDNF) vs. FAQ at 3 Months}\label{fig:bdnffaq3}
\end{figure}
\begin{figure}[!h]
{\centering\includegraphics{bdnf_faq12_results.pdf}}
\caption{Log10(BDNF) vs. FAQ at 12 Months}\label{fig:bdnffaq12}
\end{figure}

\clearpage
\subsection{E-selectin vs. FAQ}
We see no significant overall association between log10(E-selectin) at baseline and FAQ scores
at either 3 or 12 months after discharge.

\begin{figure}[!h]
{\centering\includegraphics{esel_faq3_results.pdf}}
\caption{Log10(E-selectin) vs. FAQ at 3 Months}\label{fig:eselfaq3}
\end{figure}
\begin{figure}[!h]
{\centering\includegraphics{esel_faq12_results.pdf}}
\caption{Log10(E-selectin) vs. FAQ at 12 Months}\label{fig:eselfaq12}
\end{figure}

\clearpage
\subsection{PAI-1 vs. FAQ}
We see a nearly significant association between log10(PAI-1) at baseline and FAQ scores at 3 months
after discharge, modified by age and possibly log10(IL-6). This association is no longer present by
12-month followup.

\begin{figure}[!h]
{\centering\includegraphics{pai1_faq3_results.pdf}}
\caption{Log10(PAI-1) vs. FAQ at 3 Months}\label{fig:pai1faq3}
\end{figure}
\begin{figure}[!h]
{\centering\includegraphics{pai1_faq12_results.pdf}}
\caption{Log10(PAI-1) vs. FAQ at 12 Months}\label{fig:pai1faq12}
\end{figure}

\clearpage
\subsection{S100B vs. FAQ}
At 3 months, there is not a strongly significant relationship between log10(S100B) and FAQ scores, although there does seem to be a potential interaction with systemic inflammation. At 12 months, however, log10(S100B) does have a marginally significant association with FAQ scores, strongly modified by age at enrollment such that in younger patients, higher log10(S100B) is associated with worse FAQ scores, but this association fades with age.

\begin{figure}[!h]
{\centering\includegraphics{s100b_faq3_results.pdf}}
\caption{Log10(S100B) vs. FAQ at 3 Months}\label{fig:s100bfaq3}
\end{figure}
\begin{figure}[!h]
{\centering\includegraphics{s100b_faq12_results.pdf}}
\caption{Log10(S100B) vs. FAQ at 12 Months}\label{fig:s100bfaq12}
\end{figure}

\clearpage
\subsection{UCHL vs. FAQ}
We see no significant overall association between log10(UCHL) at baseline and FAQ scores at
either 3 or 12 months after discharge.

\begin{figure}[!h]
{\centering\includegraphics{uchl_faq3_results.pdf}}
\caption{Log10(UCHL) vs. FAQ at 3 Months}\label{fig:uchlfaq3}
\end{figure}
\begin{figure}[!h]
{\centering\includegraphics{bdnf_faq12_results.pdf}}
\caption{Log10(UCHL) vs. FAQ at 12 Months}\label{fig:uchlfaq12}
\end{figure}



\section{Endothelial/BBB Injury Markers vs. RBANS Global Score}

To examine the association between endothelial/BBB injury at study enrollment and RBANS global scores at 3- and 12-month followup, we used linear regression, adjusting for the following
covariates:
\begin{itemize}
\item Charlson score
\item Years of education
\item IQCODE score
\item Framingham stroke risk score
\item Mean daily modified SOFA (no GCS) during ICU stay
\item Duration of severe sepsis
\item Duration of delirium
\item Duration of coma
\end{itemize}

We checked residual vs. fitted and QQ plots to ensure that model assumptions were met adequately.

All continuous variables, including biomarkers, were initially allowed to have a nonlinear
relationship with the outcome, with the exception of IQCODE, which had too little variability to
allow for splines. If the global p-value for nonlinearity was clearly nonsignificant
(p $>$ \Sexpr{pcutoff}), nonlinear terms were removed from the model for parsimony. We allowed for
potential interactions between endothelial/BBB markers and both systemic inflammation (log10(IL-6))
on study day 1 and age at study enrollment. If the global p-value for interactions were clearly nonsignificant (p $>$ \Sexpr{format(pcutoff, nsmall = 2)}), those terms are removed from the final
model for parsimony. All biomarkers are transformed using the log10 transformation in order to improve model fit and reduce the influence of extremely high values. All p-values are calculated using the \Sexpr{use.method} method.

% We used multiple imputation to reduce bias from missing covariates.

For models where interaction terms are kept in the final model, the association of the biomarker is
shown for the 25th, 50th, 75th, and 90th percentiles of the interacting variable.

<<rbansmodels>>=
## Formula for full delirium model, subbing "markervar" in place of actual biomarker variable
rbans.righthand <- "rcs(charlson.score, 3) + rcs(edu, 3) + iqcode.score.e + rcs(stroke.risk, 3) + rcs(mean.modsofa.icu, 3) + rcs(icudays.sevseptic.s, 3) + rcs(del.s.imp, 3) + rcs(coma.s.imp, 3) + rcs(age.div10, 3) + rcs(il6.log10, 3) + rcs(markervar, 3) + rcs(age.div10, 3):rcs(markervar, 3) + rcs(il6.log10, 3):rcs(markervar, 3)"

rbans.full.formula.3 <- paste('rbans.global.score.3', rbans.righthand, sep = ' ~ ')
rbans.full.formula.12 <- paste('rbans.global.score.12', rbans.righthand, sep = ' ~ ')

fit.rbans.models.3 <- function(marker){
  fit.reg.models(use.marker = marker, formula.full = rbans.full.formula.3, modtype = 'ols')
}
bdnf.rbans.3 <- fit.rbans.models.3('bdnf.log10')
esel.rbans.3 <- fit.rbans.models.3('esel.log10')
pai1.rbans.3 <- fit.rbans.models.3('pai1.log10')
s100b.rbans.3 <- fit.rbans.models.3('s100b.log10')
uchl.rbans.3 <- fit.rbans.models.3('uchl.log10')

fit.rbans.models.12 <- function(marker){
  fit.reg.models(use.marker = marker, formula.full = rbans.full.formula.12, modtype = 'ols')
}
bdnf.rbans.12 <- fit.rbans.models.12('bdnf.log10')
esel.rbans.12 <- fit.rbans.models.12('esel.log10')
pai1.rbans.12 <- fit.rbans.models.12('pai1.log10')
s100b.rbans.12 <- fit.rbans.models.12('s100b.log10')
uchl.rbans.12 <- fit.rbans.models.12('uchl.log10')

# ## Test by hand with S100B
# ## Fit full model
# s100b.full.rbans.3 <- ols(rbans.global.score.3 ~ rcs(charlson.score, 3) + rcs(edu, 3) +
#                             iqcode.score.e + rcs(stroke.risk, 3) + rcs(mean.modsofa.icu, 3) +
#                             rcs(icudays.sevseptic.s, 3) + rcs(del.s.imp, 3) + rcs(coma.s.imp, 3) +
#                             rcs(age.div10, 3) + rcs(il6.log10, 3) + rcs(s100b.log10, 3) +
#                             rcs(age.div10, 3):rcs(s100b.log10, 3) +
#                             rcs(il6.log10, 3):rcs(s100b.log10, 3),
#                           data = endo.data)
# 
# ## Fit model without nonlinear terms
# s100b.lin.rbans.3 <- ols(rbans.global.score.3 ~ charlson.score + edu + iqcode.score.e +
#                            stroke.risk + mean.modsofa.icu + icudays.sevseptic.s + del.s.imp +
#                            coma.s.imp + age.div10 + il6.log10 + s100b.log10 +
#                            age.div10:s100b.log10 + il6.log10:s100b.log10,
#                           data = endo.data)
# 
# lmtest::lrtest(s100b.full.rbans.3, s100b.lin.rbans.3)
# s100b.rbans.3$p.nonlin
# 
# ## Nonlinear terms needed; fit without interaction terms
# s100b.noint.rbans.3 <- ols(rbans.global.score.3 ~ rcs(charlson.score, 3) + rcs(edu, 3) +
#                              iqcode.score.e + rcs(stroke.risk, 3) + rcs(mean.modsofa.icu, 3) +
#                              rcs(icudays.sevseptic.s, 3) + rcs(del.s.imp, 3) + rcs(coma.s.imp, 3) +
#                              rcs(age.div10, 3) + rcs(il6.log10, 3) + rcs(s100b.log10, 3),
#                            data = endo.data)
# 
# lmtest::lrtest(s100b.full.rbans.3, s100b.noint.rbans.3)
# s100b.rbans.3$p.int
# 
# ## Interaction terms needed; get individual p-values for age and IL-6 interactions
# s100b.noage.rbans.3 <- ols(rbans.global.score.3 ~ rcs(charlson.score, 3) + rcs(edu, 3) +
#                              iqcode.score.e + rcs(stroke.risk, 3) + rcs(mean.modsofa.icu, 3) +
#                              rcs(icudays.sevseptic.s, 3) + rcs(del.s.imp, 3) + rcs(coma.s.imp, 3) +
#                              rcs(age.div10, 3) + rcs(il6.log10, 3) + rcs(s100b.log10, 3) +
#                              rcs(il6.log10, 3):rcs(s100b.log10, 3),
#                            data = endo.data)
# lmtest::lrtest(s100b.full.rbans.3, s100b.noage.rbans.3)
# s100b.rbans.3$p.int.age
# 
# s100b.noil6.rbans.3 <- ols(rbans.global.score.3 ~ rcs(charlson.score, 3) + rcs(edu, 3) +
#                              iqcode.score.e + rcs(stroke.risk, 3) + rcs(mean.modsofa.icu, 3) +
#                              rcs(icudays.sevseptic.s, 3) + rcs(del.s.imp, 3) + rcs(coma.s.imp, 3) +
#                              rcs(age.div10, 3) + rcs(il6.log10, 3) + rcs(s100b.log10, 3) +
#                              rcs(age.div10, 3):rcs(s100b.log10, 3),
#                            data = endo.data)
# lmtest::lrtest(s100b.full.rbans.3, s100b.noil6.rbans.3)
# s100b.rbans.3$p.int.il6
# 
# ## Get p-value for biomarker
# nomark.full.rbans.3 <- ols(rbans.global.score.3 ~ rcs(charlson.score, 3) + rcs(edu, 3) +
#                              iqcode.score.e + rcs(stroke.risk, 3) + rcs(mean.modsofa.icu, 3) +
#                              rcs(icudays.sevseptic.s, 3) + rcs(del.s.imp, 3) + rcs(coma.s.imp, 3) +
#                              rcs(age.div10, 3) + rcs(il6.log10, 3),
#                            data = endo.data)
# lmtest::lrtest(s100b.full.rbans.3, nomark.full.rbans.3)
# s100b.rbans.3$p.marker

# ## -- Get data set of predicted values for linear models -------------------------------------------
# marker <- 'bdnf.log10'
# junk <- eval(parse(text = paste0('as.data.frame(Predict(', 'bdnf.rbans.3$final.mod', ', ', marker, ' = NA))')))


@





\clearpage
\section{Technical Details}

<<choosepkgs>>=
relevant.pkgs <-
  data.frame(pkg = c('dplyr', 'ggplot2', 'knitr', 'Hmisc', 'MASS', 'mice', 'rms', 'tidyr'),
             rsn = c('Data management', 'Plotting', 'Reproducible reporting',
                     'Descriptive statistics', 'Modeling (spec. negative binomial)',
                     'Multiple imputation', 'Modeling (spec. linear regression)',
                     'Data management'))
use.packages <- session_info()$packages %>%
  filter(package %in% relevant.pkgs$pkg) %>%
  mutate(reason = relevant.pkgs$rsn[match(package, relevant.pkgs$pkg)]) %>%
  select(-2)

@

All analyses were produced using \Sexpr{session_info()$platform$version}, along with the following
add-on packages and primary reason for their use.

<<printpkgs, results='asis'>>=
latex(use.packages, file = '',
      where = '!h',
      rowname = NULL,
      caption = 'List of Add-On R Packages',
      col.just = c('l', 'r', 'r', 'l', 'l'),
      colheads = capitalize(names(use.packages)))
@

\end{document}
